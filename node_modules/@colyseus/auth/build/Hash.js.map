{
  "version": 3,
  "sources": ["../src/Hash.ts"],
  "sourcesContent": ["import crypto from 'crypto';\n\ntype HashPasswordAlgorihtm = (password: string, salt?: string) => Promise<string> | string;\ntype HashAlgorithm = \"sha1\" | \"scrypt\" | string;\n\nexport class Hash {\n  static algorithm: HashAlgorithm = \"scrypt\";\n  static algorithms: {[id: HashAlgorithm]: HashPasswordAlgorihtm} = {\n    \"sha1\": (password: string, salt: string) => crypto.createHash(\"sha1\").update(password + salt).digest(\"hex\"),\n    \"scrypt\": (password: string, salt: string) => new Promise<string>((resolve, reject) => {\n      crypto.scrypt(password, salt, 64, (err, derivedKey) => {\n        if (err) reject(err);\n        resolve(derivedKey.toString('hex'));\n      });\n    }),\n  };\n\n  /**\n   * Make a hash from a password\n   *\n   * @param password Password to be hashed\n   * @param salt Password salt\n   *\n   * @returns Hashed password\n   */\n  static async make(password: string, salt: string = process.env.AUTH_SALT || \"## SALT ##\") {\n    return await this.algorithms[this.algorithm](password, salt);\n  }\n\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAAmB;AAKZ,MAAM,KAAK;AAAA,EAChB;AAAA,SAAO,YAA2B;AAAA;AAAA,EAClC;AAAA,SAAO,aAA2D;AAAA,MAChE,QAAQ,CAAC,UAAkB,SAAiB,cAAAA,QAAO,WAAW,MAAM,EAAE,OAAO,WAAW,IAAI,EAAE,OAAO,KAAK;AAAA,MAC1G,UAAU,CAAC,UAAkB,SAAiB,IAAI,QAAgB,CAAC,SAAS,WAAW;AACrF,sBAAAA,QAAO,OAAO,UAAU,MAAM,IAAI,CAAC,KAAK,eAAe;AACrD,cAAI,IAAK,QAAO,GAAG;AACnB,kBAAQ,WAAW,SAAS,KAAK,CAAC;AAAA,QACpC,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,aAAa,KAAK,UAAkB,OAAe,QAAQ,IAAI,aAAa,cAAc;AACxF,WAAO,MAAM,KAAK,WAAW,KAAK,SAAS,EAAE,UAAU,IAAI;AAAA,EAC7D;AAEF;",
  "names": ["crypto"]
}
