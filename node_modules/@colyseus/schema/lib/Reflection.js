"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Reflection = exports.ReflectionType = exports.ReflectionField = void 0;
const annotations_1 = require("./annotations");
const TypeContext_1 = require("./types/TypeContext");
const Metadata_1 = require("./Metadata");
const ArraySchema_1 = require("./types/custom/ArraySchema");
const Encoder_1 = require("./encoder/Encoder");
const Decoder_1 = require("./decoder/Decoder");
const Schema_1 = require("./Schema");
/**
 * Reflection
 */
class ReflectionField extends Schema_1.Schema {
}
exports.ReflectionField = ReflectionField;
__decorate([
    (0, annotations_1.type)("string")
], ReflectionField.prototype, "name", void 0);
__decorate([
    (0, annotations_1.type)("string")
], ReflectionField.prototype, "type", void 0);
__decorate([
    (0, annotations_1.type)("number")
], ReflectionField.prototype, "referencedType", void 0);
class ReflectionType extends Schema_1.Schema {
    constructor() {
        super(...arguments);
        this.fields = new ArraySchema_1.ArraySchema();
    }
}
exports.ReflectionType = ReflectionType;
__decorate([
    (0, annotations_1.type)("number")
], ReflectionType.prototype, "id", void 0);
__decorate([
    (0, annotations_1.type)("number")
], ReflectionType.prototype, "extendsId", void 0);
__decorate([
    (0, annotations_1.type)([ReflectionField])
], ReflectionType.prototype, "fields", void 0);
class Reflection extends Schema_1.Schema {
    constructor() {
        super(...arguments);
        this.types = new ArraySchema_1.ArraySchema();
    }
    /**
     * Encodes the TypeContext of an Encoder into a buffer.
     *
     * @param encoder Encoder instance
     * @param it
     * @returns
     */
    static encode(encoder, it = { offset: 0 }) {
        const context = encoder.context;
        const reflection = new Reflection();
        const reflectionEncoder = new Encoder_1.Encoder(reflection);
        // rootType is usually the first schema passed to the Encoder
        // (unless it inherits from another schema)
        const rootType = context.schemas.get(encoder.state.constructor);
        if (rootType > 0) {
            reflection.rootType = rootType;
        }
        const buildType = (currentType, metadata) => {
            for (const fieldIndex in metadata) {
                const index = Number(fieldIndex);
                const fieldName = metadata[index].name;
                // skip fields from parent classes
                if (!Object.prototype.hasOwnProperty.call(metadata, fieldName)) {
                    continue;
                }
                const field = new ReflectionField();
                field.name = fieldName;
                let fieldType;
                const type = metadata[index].type;
                if (typeof (type) === "string") {
                    fieldType = type;
                }
                else {
                    let childTypeSchema;
                    //
                    // TODO: refactor below.
                    //
                    if (Schema_1.Schema.is(type)) {
                        fieldType = "ref";
                        childTypeSchema = type;
                    }
                    else {
                        fieldType = Object.keys(type)[0];
                        if (typeof (type[fieldType]) === "string") {
                            fieldType += ":" + type[fieldType]; // array:string
                        }
                        else {
                            childTypeSchema = type[fieldType];
                        }
                    }
                    field.referencedType = (childTypeSchema)
                        ? context.getTypeId(childTypeSchema)
                        : -1;
                }
                field.type = fieldType;
                currentType.fields.push(field);
            }
            reflection.types.push(currentType);
        };
        for (let typeid in context.types) {
            const klass = context.types[typeid];
            const type = new ReflectionType();
            type.id = Number(typeid);
            // support inheritance
            const inheritFrom = Object.getPrototypeOf(klass);
            if (inheritFrom !== Schema_1.Schema) {
                type.extendsId = context.schemas.get(inheritFrom);
            }
            buildType(type, klass[Symbol.metadata]);
        }
        const buf = reflectionEncoder.encodeAll(it);
        return Buffer.from(buf, 0, it.offset);
    }
    /**
     * Decodes the TypeContext from a buffer into a Decoder instance.
     *
     * @param bytes Reflection.encode() output
     * @param it
     * @returns Decoder instance
     */
    static decode(bytes, it) {
        const reflection = new Reflection();
        const reflectionDecoder = new Decoder_1.Decoder(reflection);
        reflectionDecoder.decode(bytes, it);
        const typeContext = new TypeContext_1.TypeContext();
        // 1st pass, initialize metadata + inheritance
        reflection.types.forEach((reflectionType) => {
            const parentClass = typeContext.get(reflectionType.extendsId) ?? Schema_1.Schema;
            const schema = class _ extends parentClass {
            };
            // register for inheritance support
            TypeContext_1.TypeContext.register(schema);
            // // for inheritance support
            // Metadata.initialize(schema);
            typeContext.add(schema, reflectionType.id);
        }, {});
        // define fields
        const addFields = (metadata, reflectionType, parentFieldIndex) => {
            reflectionType.fields.forEach((field, i) => {
                const fieldIndex = parentFieldIndex + i;
                if (field.referencedType !== undefined) {
                    let fieldType = field.type;
                    let refType = typeContext.get(field.referencedType);
                    // map or array of primitive type (-1)
                    if (!refType) {
                        const typeInfo = field.type.split(":");
                        fieldType = typeInfo[0];
                        refType = typeInfo[1]; // string
                    }
                    if (fieldType === "ref") {
                        Metadata_1.Metadata.addField(metadata, fieldIndex, field.name, refType);
                    }
                    else {
                        Metadata_1.Metadata.addField(metadata, fieldIndex, field.name, { [fieldType]: refType });
                    }
                }
                else {
                    Metadata_1.Metadata.addField(metadata, fieldIndex, field.name, field.type);
                }
            });
        };
        // 2nd pass, set fields
        reflection.types.forEach((reflectionType) => {
            const schema = typeContext.get(reflectionType.id);
            // for inheritance support
            const metadata = Metadata_1.Metadata.initialize(schema);
            const inheritedTypes = [];
            let parentType = reflectionType;
            do {
                inheritedTypes.push(parentType);
                parentType = reflection.types.find((t) => t.id === parentType.extendsId);
            } while (parentType);
            let parentFieldIndex = 0;
            inheritedTypes.reverse().forEach((reflectionType) => {
                // add fields from all inherited classes
                // TODO: refactor this to avoid adding fields from parent classes
                addFields(metadata, reflectionType, parentFieldIndex);
                parentFieldIndex += reflectionType.fields.length;
            });
        });
        const state = new (typeContext.get(reflection.rootType || 0))();
        return new Decoder_1.Decoder(state, typeContext);
    }
}
exports.Reflection = Reflection;
__decorate([
    (0, annotations_1.type)([ReflectionType])
], Reflection.prototype, "types", void 0);
__decorate([
    (0, annotations_1.type)("number")
], Reflection.prototype, "rootType", void 0);
//# sourceMappingURL=Reflection.js.map