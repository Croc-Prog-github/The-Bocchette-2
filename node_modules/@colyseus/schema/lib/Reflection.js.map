{"version":3,"file":"Reflection.js","sourceRoot":"","sources":["../src/Reflection.ts"],"names":[],"mappings":"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","sourcesContent":["import { type, PrimitiveType } from \"./annotations\";\nimport { TypeContext } from \"./types/TypeContext\";\nimport { Metadata } from \"./Metadata\";\nimport { ArraySchema } from \"./types/custom/ArraySchema\";\nimport { Iterator } from \"./encoding/decode\";\nimport { Encoder } from \"./encoder/Encoder\";\nimport { Decoder } from \"./decoder/Decoder\";\nimport { Schema } from \"./Schema\";\n\n/**\n * Reflection\n */\nexport class ReflectionField extends Schema {\n    @type(\"string\") name: string;\n    @type(\"string\") type: string;\n    @type(\"number\") referencedType: number;\n}\n\nexport class ReflectionType extends Schema {\n    @type(\"number\") id: number;\n    @type(\"number\") extendsId: number;\n    @type([ ReflectionField ]) fields = new ArraySchema<ReflectionField>();\n}\n\nexport class Reflection extends Schema {\n    @type([ReflectionType]) types: ArraySchema<ReflectionType> = new ArraySchema<ReflectionType>();\n    @type(\"number\") rootType: number;\n\n    /**\n     * Encodes the TypeContext of an Encoder into a buffer.\n     *\n     * @param encoder Encoder instance\n     * @param it\n     * @returns\n     */\n    static encode(encoder: Encoder, it: Iterator = { offset: 0 }) {\n        const context = encoder.context;\n\n        const reflection = new Reflection();\n        const reflectionEncoder = new Encoder(reflection);\n\n        // rootType is usually the first schema passed to the Encoder\n        // (unless it inherits from another schema)\n        const rootType = context.schemas.get(encoder.state.constructor);\n        if (rootType > 0) { reflection.rootType = rootType; }\n\n        const buildType = (currentType: ReflectionType, metadata: Metadata) => {\n            for (const fieldIndex in metadata) {\n                const index = Number(fieldIndex);\n                const fieldName = metadata[index].name;\n\n                // skip fields from parent classes\n                if (!Object.prototype.hasOwnProperty.call(metadata, fieldName)) {\n                    continue;\n                }\n\n                const field = new ReflectionField();\n                field.name = fieldName;\n\n                let fieldType: string;\n\n                const type = metadata[index].type;\n\n                if (typeof (type) === \"string\") {\n                    fieldType = type;\n\n                } else {\n                    let childTypeSchema: typeof Schema;\n\n                    //\n                    // TODO: refactor below.\n                    //\n                    if (Schema.is(type)) {\n                        fieldType = \"ref\";\n                        childTypeSchema = type as typeof Schema;\n\n                    } else {\n                        fieldType = Object.keys(type)[0];\n\n                        if (typeof(type[fieldType]) === \"string\") {\n                            fieldType += \":\" + type[fieldType]; // array:string\n\n                        } else {\n                            childTypeSchema = type[fieldType];\n                        }\n                    }\n\n                    field.referencedType = (childTypeSchema)\n                        ? context.getTypeId(childTypeSchema)\n                        : -1;\n                }\n\n                field.type = fieldType;\n                currentType.fields.push(field);\n            }\n\n            reflection.types.push(currentType);\n        }\n\n        for (let typeid in context.types) {\n            const klass = context.types[typeid];\n            const type = new ReflectionType();\n            type.id = Number(typeid);\n\n            // support inheritance\n            const inheritFrom = Object.getPrototypeOf(klass);\n            if (inheritFrom !== Schema) {\n                type.extendsId = context.schemas.get(inheritFrom);\n            }\n\n            buildType(type, klass[Symbol.metadata]);\n        }\n\n        const buf = reflectionEncoder.encodeAll(it);\n        return Buffer.from(buf, 0, it.offset);\n    }\n\n    /**\n     * Decodes the TypeContext from a buffer into a Decoder instance.\n     *\n     * @param bytes Reflection.encode() output\n     * @param it\n     * @returns Decoder instance\n     */\n    static decode<T extends Schema = Schema>(bytes: Buffer, it?: Iterator): Decoder<T> {\n        const reflection = new Reflection();\n\n        const reflectionDecoder = new Decoder(reflection);\n        reflectionDecoder.decode(bytes, it);\n\n        const typeContext = new TypeContext();\n\n        // 1st pass, initialize metadata + inheritance\n        reflection.types.forEach((reflectionType) => {\n            const parentClass: typeof Schema = typeContext.get(reflectionType.extendsId) ?? Schema;\n            const schema: typeof Schema = class _ extends parentClass {};\n\n            // register for inheritance support\n            TypeContext.register(schema);\n\n            // // for inheritance support\n            // Metadata.initialize(schema);\n\n            typeContext.add(schema, reflectionType.id);\n        }, {});\n\n        // define fields\n        const addFields = (metadata: Metadata, reflectionType: ReflectionType, parentFieldIndex: number) => {\n            reflectionType.fields.forEach((field, i) => {\n                const fieldIndex = parentFieldIndex + i;\n\n                if (field.referencedType !== undefined) {\n                    let fieldType = field.type;\n                    let refType: PrimitiveType = typeContext.get(field.referencedType);\n\n                    // map or array of primitive type (-1)\n                    if (!refType) {\n                        const typeInfo = field.type.split(\":\");\n                        fieldType = typeInfo[0];\n                        refType = typeInfo[1] as PrimitiveType; // string\n                    }\n\n                    if (fieldType === \"ref\") {\n                        Metadata.addField(metadata, fieldIndex, field.name, refType);\n\n                    } else {\n                        Metadata.addField(metadata, fieldIndex, field.name, { [fieldType]: refType });\n                    }\n\n                } else {\n                    Metadata.addField(metadata, fieldIndex, field.name, field.type as PrimitiveType);\n                }\n            });\n        };\n\n        // 2nd pass, set fields\n        reflection.types.forEach((reflectionType) => {\n            const schema = typeContext.get(reflectionType.id);\n\n            // for inheritance support\n            const metadata = Metadata.initialize(schema);\n\n            const inheritedTypes: ReflectionType[] = [];\n\n            let parentType: ReflectionType = reflectionType;\n            do {\n                inheritedTypes.push(parentType);\n                parentType = reflection.types.find((t) => t.id === parentType.extendsId);\n            } while (parentType);\n\n            let parentFieldIndex = 0;\n\n            inheritedTypes.reverse().forEach((reflectionType) => {\n                // add fields from all inherited classes\n                // TODO: refactor this to avoid adding fields from parent classes\n                addFields(metadata, reflectionType, parentFieldIndex);\n                parentFieldIndex += reflectionType.fields.length;\n            });\n        });\n\n        const state: T = new (typeContext.get(reflection.rootType || 0) as unknown as any)();\n\n        return new Decoder<T>(state, typeContext);\n    }\n}\n"]}