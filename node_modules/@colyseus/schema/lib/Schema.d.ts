import { OPERATION } from './encoding/spec';
import { type DefinitionType } from "./annotations";
import { NonFunctionPropNames, ToJSON } from './types/HelperTypes';
import { ChangeTree, Ref } from './encoder/ChangeTree';
import { $decoder, $deleteByIndex, $encoder, $filter, $getByIndex, $track } from './types/symbols';
import { StateView } from './encoder/StateView';
/**
 * Schema encoder / decoder
 */
export declare class Schema {
    static [$encoder]: import("./encoder/EncodeOperation").EncodeOperation<any>;
    static [$decoder]: import("./decoder/DecodeOperation").DecodeOperation<any>;
    /**
     * Assign the property descriptors required to track changes on this instance.
     * @param instance
     */
    static initialize(instance: any): void;
    static is(type: DefinitionType): boolean;
    /**
     * Track property changes
     */
    static [$track](changeTree: ChangeTree, index: number, operation?: OPERATION): void;
    /**
     * Determine if a property must be filtered.
     * - If returns false, the property is NOT going to be encoded.
     * - If returns true, the property is going to be encoded.
     *
     * Encoding with "filters" happens in two steps:
     * - First, the encoder iterates over all "not owned" properties and encodes them.
     * - Then, the encoder iterates over all "owned" properties per instance and encodes them.
     */
    static [$filter](ref: Schema, index: number, view: StateView): boolean;
    constructor(...args: any[]);
    assign(props: {
        [prop in NonFunctionPropNames<this>]?: this[prop];
    } | ToJSON<this>): this;
    /**
     * (Server-side): Flag a property to be encoded for the next patch.
     * @param instance Schema instance
     * @param property string representing the property name, or number representing the index of the property.
     * @param operation OPERATION to perform (detected automatically)
     */
    setDirty<K extends NonFunctionPropNames<this>>(property: K | number, operation?: OPERATION): void;
    clone(): this;
    toJSON(): ToJSON<typeof this>;
    discardAllChanges(): void;
    protected [$getByIndex](index: number): any;
    protected [$deleteByIndex](index: number): void;
    /**
     * Inspect the `refId` of all Schema instances in the tree. Optionally display the contents of the instance.
     *
     * @param ref Schema instance
     * @param showContents display JSON contents of the instance
     * @returns
     */
    static debugRefIds(ref: Ref, showContents?: boolean, level?: number): string;
    /**
     * Return a string representation of the changes on a Schema instance.
     * The list of changes is cleared after each encode.
     *
     * @param instance Schema instance
     * @param isEncodeAll Return "full encode" instead of current change set.
     * @returns
     */
    static debugChanges(instance: Ref, isEncodeAll?: boolean): string;
    static debugChangesDeep(ref: Ref, changeSetName?: "changes" | "allChanges" | "allFilteredChanges" | "filteredChanges"): string;
}
