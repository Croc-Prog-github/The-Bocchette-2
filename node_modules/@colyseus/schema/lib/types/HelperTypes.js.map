{"version":3,"file":"HelperTypes.js","sourceRoot":"","sources":["../../src/types/HelperTypes.ts"],"names":[],"mappings":"","sourcesContent":["import type { Definition, DefinitionType, PrimitiveType, RawPrimitiveType } from \"../annotations\";\nimport type { Schema } from \"../Schema\";\nimport type { ArraySchema } from \"./custom/ArraySchema\";\nimport type { CollectionSchema } from \"./custom/CollectionSchema\";\nimport type { MapSchema } from \"./custom/MapSchema\";\nimport type { SetSchema } from \"./custom/SetSchema\";\n\nexport type Constructor<T = {}> = new (...args: any[]) => T;\n\nexport interface Collection<K = any, V = any, IT = V> {\n    [Symbol.iterator](): IterableIterator<IT>;\n    forEach(callback: Function);\n    entries(): IterableIterator<[K, V]>;\n}\n\nexport type InferValueType<T extends DefinitionType> =\n    T extends \"string\" ? string\n    : T extends \"number\" ? number\n    : T extends \"int8\" ? number\n    : T extends \"uint8\" ? number\n    : T extends \"int16\" ? number\n    : T extends \"uint16\" ? number\n    : T extends \"int32\" ? number\n    : T extends \"uint32\" ? number\n    : T extends \"int64\" ? number\n    : T extends \"uint64\" ? number\n    : T extends \"float32\" ? number\n    : T extends \"float64\" ? number\n    : T extends \"boolean\" ? boolean\n\n    : T extends { type: infer ChildType extends Constructor } ? InstanceType<ChildType>\n    : T extends { type: infer ChildType extends PrimitiveType } ? ChildType\n\n    : T extends Array<infer ChildType extends Constructor> ? InstanceType<ChildType>[]\n    : T extends Array<infer ChildType extends RawPrimitiveType> ? ChildType[]\n\n    : T extends { array: infer ChildType extends Constructor } ? InstanceType<ChildType>[]\n    : T extends { array: infer ChildType extends PrimitiveType } ? ChildType[]\n\n    : T extends { map: infer ChildType extends Constructor } ? MapSchema<InstanceType<ChildType>>\n    : T extends { map: infer ChildType extends PrimitiveType } ? MapSchema<ChildType>\n\n    : T extends { set: infer ChildType extends Constructor } ? SetSchema<InstanceType<ChildType>>\n    : T extends { set: infer ChildType extends PrimitiveType } ? SetSchema<ChildType>\n\n    : T extends { collection: infer ChildType extends Constructor } ? CollectionSchema<InstanceType<ChildType>>\n    : T extends { collection: infer ChildType extends PrimitiveType } ? CollectionSchema<ChildType>\n\n    : T extends Constructor ? InstanceType<T>\n    : T extends PrimitiveType ? T\n\n    : never;\n\nexport type InferSchemaInstanceType<T extends Definition> = {\n    [K in keyof T]: InferValueType<T[K]>\n} & Schema;\n\nexport type DefinedSchemaType<T extends Definition, P extends typeof Schema> = {\n    new (): InferSchemaInstanceType<T> & InstanceType<P>;\n} & typeof Schema;\n\nexport type NonFunctionProps<T> = Omit<T, {\n    [K in keyof T]: T[K] extends Function ? K : never;\n}[keyof T]>;\n\nexport type NonFunctionPropNames<T> = {\n    [K in keyof T]: T[K] extends Function ? never : K\n}[keyof T];\n\nexport type NonFunctionNonPrimitivePropNames<T> = {\n    [K in keyof T]: T[K] extends Function\n        ? never\n        : T[K] extends number | string | boolean\n            ? never\n            : K\n}[keyof T];\n\nexport type ToJSON<T> = NonFunctionProps<{\n    [K in keyof T]: T[K] extends MapSchema<infer U>\n        ? Record<string, U>\n        : T[K] extends Map<string, infer U>\n            ? Record<string, U>\n            : T[K] extends ArraySchema<infer U>\n                ? U[]\n                : T[K]\n}>;"]}