{"version":3,"file":"annotations.js","sourceRoot":"","sources":["../src/annotations.ts"],"names":[],"mappings":"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","sourcesContent":["import \"./symbol.shim\";\nimport { Schema } from './Schema';\nimport { ArraySchema } from './types/custom/ArraySchema';\nimport { MapSchema } from './types/custom/MapSchema';\nimport { Metadata } from \"./Metadata\";\nimport { $changes, $childType, $descriptors, $numFields, $track } from \"./types/symbols\";\nimport { TypeDefinition, getType } from \"./types/registry\";\nimport { OPERATION } from \"./encoding/spec\";\nimport { TypeContext } from \"./types/TypeContext\";\nimport { assertInstanceType, assertType } from \"./encoding/assert\";\nimport type { Ref } from \"./encoder/ChangeTree\";\nimport type { DefinedSchemaType, InferValueType } from \"./types/HelperTypes\";\nimport type { CollectionSchema } from \"./types/custom/CollectionSchema\";\nimport type { SetSchema } from \"./types/custom/SetSchema\";\n\nexport type RawPrimitiveType = \"string\" |\n    \"number\" |\n    \"boolean\" |\n    \"int8\" |\n    \"uint8\" |\n    \"int16\" |\n    \"uint16\" |\n    \"int32\" |\n    \"uint32\" |\n    \"int64\" |\n    \"uint64\" |\n    \"float32\" |\n    \"float64\" |\n    \"bigint64\" |\n    \"biguint64\";\n\nexport type PrimitiveType = RawPrimitiveType | typeof Schema | object;\n\n// TODO: infer \"default\" value type correctly.\nexport type DefinitionType<T extends PrimitiveType = PrimitiveType> = T\n    | T[]\n    | { type: T, default?: InferValueType<T>, view?: boolean | number }\n    | { array: T, default?: ArraySchema<InferValueType<T>>, view?: boolean | number }\n    | { map: T, default?: MapSchema<InferValueType<T>>, view?: boolean | number }\n    | { collection: T, default?: CollectionSchema<InferValueType<T>>, view?: boolean | number }\n    | { set: T, default?: SetSchema<InferValueType<T>>, view?: boolean | number };\n\nexport type Definition = { [field: string]: DefinitionType };\n\nexport interface TypeOptions {\n    manual?: boolean,\n}\n\nexport const DEFAULT_VIEW_TAG = -1;\n\nexport function entity(constructor) {\n    TypeContext.register(constructor);\n    return constructor;\n}\n\n/**\n * [See documentation](https://docs.colyseus.io/state/schema/)\n *\n * Annotate a Schema property to be serializeable.\n * \\@type()'d fields are automatically flagged as \"dirty\" for the next patch.\n *\n * @example Standard usage, with automatic change tracking.\n * ```\n * \\@type(\"string\") propertyName: string;\n * ```\n *\n * @example You can provide the \"manual\" option if you'd like to manually control your patches via .setDirty().\n * ```\n * \\@type(\"string\", { manual: true })\n * ```\n */\n// export function type(type: DefinitionType, options?: TypeOptions) {\n//     return function ({ get, set }, context: ClassAccessorDecoratorContext): ClassAccessorDecoratorResult<Schema, any> {\n//         if (context.kind !== \"accessor\") {\n//             throw new Error(\"@type() is only supported for class accessor properties\");\n//         }\n\n//         const field = context.name.toString();\n\n//         //\n//         // detect index for this field, considering inheritance\n//         //\n//         const parent = Object.getPrototypeOf(context.metadata);\n//         let fieldIndex: number = context.metadata[$numFields] // current structure already has fields defined\n//             ?? (parent && parent[$numFields]) // parent structure has fields defined\n//             ?? -1; // no fields defined\n//         fieldIndex++;\n\n//         if (\n//             !parent && // the parent already initializes the `$changes` property\n//             !Metadata.hasFields(context.metadata)\n//         ) {\n//             context.addInitializer(function (this: Ref) {\n//                 Object.defineProperty(this, $changes, {\n//                     value: new ChangeTree(this),\n//                     enumerable: false,\n//                     writable: true\n//                 });\n//             });\n//         }\n\n//         Metadata.addField(context.metadata, fieldIndex, field, type);\n\n//         const isArray = ArraySchema.is(type);\n//         const isMap = !isArray && MapSchema.is(type);\n\n//         // if (options && options.manual) {\n//         //     // do not declare getter/setter descriptor\n//         //     definition.descriptors[field] = {\n//         //         enumerable: true,\n//         //         configurable: true,\n//         //         writable: true,\n//         //     };\n//         //     return;\n//         // }\n\n//         return {\n//             init(value) {\n//                 // TODO: may need to convert ArraySchema/MapSchema here\n\n//                 // do not flag change if value is undefined.\n//                 if (value !== undefined) {\n//                     this[$changes].change(fieldIndex);\n\n//                     // automaticallty transform Array into ArraySchema\n//                     if (isArray) {\n//                         if (!(value instanceof ArraySchema)) {\n//                             value = new ArraySchema(...value);\n//                         }\n//                         value[$childType] = Object.values(type)[0];\n//                     }\n\n//                     // automaticallty transform Map into MapSchema\n//                     if (isMap) {\n//                         if (!(value instanceof MapSchema)) {\n//                             value = new MapSchema(value);\n//                         }\n//                         value[$childType] = Object.values(type)[0];\n//                     }\n\n//                     // try to turn provided structure into a Proxy\n//                     if (value['$proxy'] === undefined) {\n//                         if (isMap) {\n//                             value = getMapProxy(value);\n//                         }\n//                     }\n\n//                 }\n\n//                 return value;\n//             },\n\n//             get() {\n//                 return get.call(this);\n//             },\n\n//             set(value: any) {\n//                 /**\n//                  * Create Proxy for array or map items\n//                  */\n\n//                 // skip if value is the same as cached.\n//                 if (value === get.call(this)) {\n//                     return;\n//                 }\n\n//                 if (\n//                     value !== undefined &&\n//                     value !== null\n//                 ) {\n//                     // automaticallty transform Array into ArraySchema\n//                     if (isArray) {\n//                         if (!(value instanceof ArraySchema)) {\n//                             value = new ArraySchema(...value);\n//                         }\n//                         value[$childType] = Object.values(type)[0];\n//                     }\n\n//                     // automaticallty transform Map into MapSchema\n//                     if (isMap) {\n//                         if (!(value instanceof MapSchema)) {\n//                             value = new MapSchema(value);\n//                         }\n//                         value[$childType] = Object.values(type)[0];\n//                     }\n\n//                     // try to turn provided structure into a Proxy\n//                     if (value['$proxy'] === undefined) {\n//                         if (isMap) {\n//                             value = getMapProxy(value);\n//                         }\n//                     }\n\n//                     // flag the change for encoding.\n//                     this[$changes].change(fieldIndex);\n\n//                     //\n//                     // call setParent() recursively for this and its child\n//                     // structures.\n//                     //\n//                     if (value[$changes]) {\n//                         value[$changes].setParent(\n//                             this,\n//                             this[$changes].root,\n//                             Metadata.getIndex(context.metadata, field),\n//                         );\n//                     }\n\n//                 } else if (get.call(this)) {\n//                     //\n//                     // Setting a field to `null` or `undefined` will delete it.\n//                     //\n//                     this[$changes].delete(field);\n//                 }\n\n//                 set.call(this, value);\n//             },\n//         };\n//     }\n// }\n\nexport function view<T> (tag: number = DEFAULT_VIEW_TAG) {\n    return function(target: T, fieldName: string) {\n        const constructor = target.constructor as typeof Schema;\n\n        const parentClass = Object.getPrototypeOf(constructor);\n        const parentMetadata = parentClass[Symbol.metadata];\n\n        // TODO: use Metadata.initialize()\n        const metadata: Metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\n        // const fieldIndex = metadata[fieldName];\n\n        // if (!metadata[fieldIndex]) {\n        //     //\n        //     // detect index for this field, considering inheritance\n        //     //\n        //     metadata[fieldIndex] = {\n        //         type: undefined,\n        //         index: (metadata[$numFields] // current structure already has fields defined\n        //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n        //             ?? -1) + 1 // no fields defined\n        //     }\n        // }\n\n        Metadata.setTag(metadata, fieldName, tag);\n    }\n}\n\nexport function unreliable<T> (target: T, field: string) {\n    //\n    // FIXME: the following block of code is repeated across `@type()`, `@deprecated()` and `@unreliable()` decorators.\n    //\n    const constructor = target.constructor as typeof Schema;\n\n    const parentClass = Object.getPrototypeOf(constructor);\n    const parentMetadata = parentClass[Symbol.metadata];\n\n    // TODO: use Metadata.initialize()\n    const metadata: Metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\n\n    // if (!metadata[field]) {\n    //     //\n    //     // detect index for this field, considering inheritance\n    //     //\n    //     metadata[field] = {\n    //         type: undefined,\n    //         index: (metadata[$numFields] // current structure already has fields defined\n    //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n    //             ?? -1) + 1 // no fields defined\n    //     }\n    // }\n\n    // add owned flag to the field\n    metadata[metadata[field]].unreliable = true;\n}\n\nexport function type (\n    type: DefinitionType,\n    options?: TypeOptions\n): PropertyDecorator {\n    return function (target: typeof Schema, field: string) {\n        const constructor = target.constructor as typeof Schema;\n\n        if (!type) {\n            throw new Error(`${constructor.name}: @type() reference provided for \"${field}\" is undefined. Make sure you don't have any circular dependencies.`);\n        }\n\n        // for inheritance support\n        TypeContext.register(constructor);\n\n        const parentClass = Object.getPrototypeOf(constructor);\n        const parentMetadata =  parentClass[Symbol.metadata];\n        const metadata = Metadata.initialize(constructor);\n\n        let fieldIndex: number = metadata[field];\n\n        /**\n         * skip if descriptor already exists for this field (`@deprecated()`)\n         */\n        if (metadata[fieldIndex] !== undefined) {\n            if (metadata[fieldIndex].deprecated) {\n                // do not create accessors for deprecated properties.\n                return;\n\n            } else if (metadata[fieldIndex].type !== undefined) {\n                // trying to define same property multiple times across inheritance.\n                // https://github.com/colyseus/colyseus-unity3d/issues/131#issuecomment-814308572\n                try {\n                    throw new Error(`@colyseus/schema: Duplicate '${field}' definition on '${constructor.name}'.\\nCheck @type() annotation`);\n\n                } catch (e) {\n                    const definitionAtLine = e.stack.split(\"\\n\")[4].trim();\n                    throw new Error(`${e.message} ${definitionAtLine}`);\n                }\n            }\n\n        } else {\n            //\n            // detect index for this field, considering inheritance\n            //\n            fieldIndex = metadata[$numFields] // current structure already has fields defined\n                ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n                ?? -1; // no fields defined\n            fieldIndex++;\n        }\n\n        if (options && options.manual) {\n            Metadata.addField(\n                metadata,\n                fieldIndex,\n                field,\n                type,\n                {\n                    // do not declare getter/setter descriptor\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                }\n            );\n\n        } else {\n            const complexTypeKlass = (Array.isArray(type))\n                ? getType(\"array\")\n                : (typeof(Object.keys(type)[0]) === \"string\") && getType(Object.keys(type)[0]);\n\n            const childType = (complexTypeKlass)\n                ? Object.values(type)[0]\n                : type;\n\n            Metadata.addField(\n                metadata,\n                fieldIndex,\n                field,\n                type,\n                getPropertyDescriptor(`_${field}`, fieldIndex, childType, complexTypeKlass)\n            );\n        }\n    }\n}\n\nexport function getPropertyDescriptor(\n    fieldCached: string,\n    fieldIndex: number,\n    type: DefinitionType,\n    complexTypeKlass: TypeDefinition,\n) {\n    return {\n        get: function () { return this[fieldCached]; },\n        set: function (this: Schema, value: any) {\n            const previousValue = this[fieldCached] ?? undefined;\n\n            // skip if value is the same as cached.\n            if (value === previousValue) { return; }\n\n            if (\n                value !== undefined &&\n                value !== null\n            ) {\n                if (complexTypeKlass) {\n                    // automaticallty transform Array into ArraySchema\n                    if (complexTypeKlass.constructor === ArraySchema && !(value instanceof ArraySchema)) {\n                        value = new ArraySchema(...value);\n                    }\n\n                    // automaticallty transform Map into MapSchema\n                    if (complexTypeKlass.constructor === MapSchema && !(value instanceof MapSchema)) {\n                        value = new MapSchema(value);\n                    }\n\n                    value[$childType] = type;\n\n                } else if (typeof (type) !== \"string\") {\n                    assertInstanceType(value, type as typeof Schema, this, fieldCached.substring(1));\n\n                } else {\n                    assertType(value, type, this, fieldCached.substring(1));\n                }\n\n                const changeTree = this[$changes];\n\n                //\n                // Replacing existing \"ref\", remove it from root.\n                // TODO: if there are other references to this instance, we should not remove it from root.\n                //\n                if (previousValue !== undefined && previousValue[$changes]) {\n                    changeTree.root?.remove(previousValue[$changes]);\n                }\n\n                // flag the change for encoding.\n                this.constructor[$track](changeTree, fieldIndex, OPERATION.ADD);\n\n                //\n                // call setParent() recursively for this and its child\n                // structures.\n                //\n                (value as Ref)[$changes]?.setParent(this, changeTree.root, fieldIndex);\n\n            } else if (previousValue !== undefined) {\n                //\n                // Setting a field to `null` or `undefined` will delete it.\n                //\n                this[$changes].delete(fieldIndex);\n            }\n\n            this[fieldCached] = value;\n        },\n\n        enumerable: true,\n        configurable: true\n    };\n}\n\n/**\n * `@deprecated()` flag a field as deprecated.\n * The previous `@type()` annotation should remain along with this one.\n */\n\nexport function deprecated(throws: boolean = true): PropertyDecorator {\n    return function (klass: typeof Schema, field: string) {\n        //\n        // FIXME: the following block of code is repeated across `@type()`, `@deprecated()` and `@unreliable()` decorators.\n        //\n        const constructor = klass.constructor as typeof Schema;\n\n        const parentClass = Object.getPrototypeOf(constructor);\n        const parentMetadata = parentClass[Symbol.metadata];\n        const metadata: Metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\n        const fieldIndex = metadata[field];\n\n        // if (!metadata[field]) {\n        //     //\n        //     // detect index for this field, considering inheritance\n        //     //\n        //     metadata[field] = {\n        //         type: undefined,\n        //         index: (metadata[$numFields] // current structure already has fields defined\n        //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n        //             ?? -1) + 1 // no fields defined\n        //     }\n        // }\n\n        metadata[fieldIndex].deprecated = true;\n\n        if (throws) {\n            metadata[$descriptors] ??= {};\n            metadata[$descriptors][field] = {\n                get: function () { throw new Error(`${field} is deprecated.`); },\n                set: function (this: Schema, value: any) { /* throw new Error(`${field} is deprecated.`); */ },\n                enumerable: false,\n                configurable: true\n            };\n        }\n\n        // flag metadata[field] as non-enumerable\n        Object.defineProperty(metadata, fieldIndex, {\n            value: metadata[fieldIndex],\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\n\nexport function defineTypes(\n    target: typeof Schema,\n    fields: Definition,\n    options?: TypeOptions\n) {\n    for (let field in fields) {\n        type(fields[field], options)(target.prototype, field);\n    }\n    return target;\n}\n\nexport interface SchemaWithExtends<T extends Definition, P extends typeof Schema> extends DefinedSchemaType<T, P> {\n    extends: <T2 extends Definition>(\n        fields: T2,\n        name?: string\n    ) => SchemaWithExtends<T & T2, typeof this>;\n}\n\nexport function schema<T extends Definition, P extends typeof Schema = typeof Schema>(\n    fields: T,\n    name?: string,\n    inherits: P = Schema as P\n): SchemaWithExtends<T, P> {\n    const defaultValues: any = {};\n    const viewTagFields: any = {};\n\n    for (let fieldName in fields) {\n        const field = fields[fieldName] as DefinitionType;\n        if (typeof (field) === \"object\") {\n            if (field['default'] !== undefined) {\n                defaultValues[fieldName] = field['default'];\n            }\n            if (field['view'] !== undefined) {\n                viewTagFields[fieldName] = (typeof (field['view']) === \"boolean\")\n                    ? DEFAULT_VIEW_TAG\n                    : field['view'];\n            }\n        }\n    }\n\n    const klass = Metadata.setFields(class extends inherits {\n        constructor (...args: any[]) {\n            args[0] = Object.assign({}, defaultValues, args[0]);\n            super(...args);\n        }\n    }, fields) as SchemaWithExtends<T, P>;\n\n    for (let fieldName in viewTagFields) {\n        view(viewTagFields[fieldName])(klass.prototype, fieldName);\n    }\n\n    if (name) {\n        Object.defineProperty(klass, \"name\", { value: name });\n    }\n\n    klass.extends = (fields, name) => schema(fields, name, klass);\n\n    return klass;\n}"]}