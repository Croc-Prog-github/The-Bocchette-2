{
  "version": 3,
  "sources": ["../../../src/matchmaker/driver/api.ts"],
  "sourcesContent": ["export interface SortOptions {\n  [fieldName: string]: 1 | -1 | 'asc' | 'desc' | 'ascending' | 'descending';\n}\n\nexport function getLockId(filterOptions: any) {\n  return Object.keys(filterOptions).map((key) => `${key}:${filterOptions[key]}`).join(\"-\");\n}\n\nexport interface IRoomCache {\n  /**\n   * Unique identifier for the room.\n   */\n  roomId: string;\n\n  /**\n   * Number of clients connected to this room.\n   */\n  clients: number;\n\n  /**\n   * Maximum number of clients allowed to join the room.\n   */\n  maxClients: number;\n\n  /**\n   * Indicates if the room is locked (i.e. join requests are rejected).\n   */\n  locked: boolean;\n\n  /**\n   * Indicates if the room is private\n   * Private rooms can't be joined via `join()` or `joinOrCreate()`.\n   */\n  private: boolean;\n\n  /**\n   * Room name.\n   */\n  name: string;\n\n  /**\n   * Public address of the server.\n   */\n  publicAddress?: string;\n\n  /**\n   * Process id where the room is running.\n   */\n  processId: string;\n\n  /**\n   * Do not show this room in lobby listing.\n   */\n  unlisted: boolean;\n\n  /**\n   * Metadata associated with the room.\n   */\n  metadata: any;\n\n  /**\n   * Additional custom properties\n   */\n  [property: string]: any;\n}\n\nexport interface RoomCache<Metadata= any> extends IRoomCache {\n  metadata: Metadata;\n\n  updateOne(operations: any);\n  save();\n  remove();\n}\n\nexport interface MatchMakerDriver {\n  /**\n   * Initialize a room cache which contains CRUD operations for room listings.\n   *\n   * @param initialValues - Predefined room properties.\n   *\n   * @returns RoomData - New room cache.\n   */\n  createInstance(initialValues: Partial<IRoomCache>): RoomCache;\n\n  /**\n   * Check if a room exists in room cache.\n   *\n   * @param roomId - The room id.\n   *\n   * @returns Promise<boolean> | boolean - A promise or a boolean value indicating if the room exists.\n   */\n  has(roomId: string): Promise<boolean> | boolean;\n\n  /**\n   * Query rooms in room cache for given conditions.\n   *\n   * @param conditions - Filtering conditions.\n   *\n   * @returns Promise<IRoomCache[]> | IRoomCache[] - A promise or an object contaning room metadata list.\n   */\n  query(conditions: Partial<IRoomCache>, sortOptions?: SortOptions,): Promise<IRoomCache[]> | IRoomCache[];\n\n  /**\n   * Clean up rooms in room cache by process id.\n   * @param processId - The process id.\n   */\n  cleanup?(processId: string): Promise<void>;\n\n  /**\n   * Query for a room in room cache for given conditions.\n   *\n   * @param conditions - Filtering conditions.\n   *\n   * @returns `IRoomCache` - An object contaning filtered room metadata.\n   */\n  findOne(conditions: Partial<IRoomCache>, sortOptions?: SortOptions): Promise<RoomCache>;\n\n  /**\n   * Empty the room cache.\n   */\n  clear(): void;\n\n  /**\n   * Dispose the connection of the room cache medium.\n   */\n  shutdown(): void;\n\n  // /**\n  //  *\n  //  */\n  // lock(): void;\n\n  // /**\n  //  *\n  //  */\n  // releaseLock(): void;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAIO,SAAS,UAAU,eAAoB;AAC5C,SAAO,OAAO,KAAK,aAAa,EAAE,IAAI,CAAC,QAAQ,GAAG,GAAG,IAAI,cAAc,GAAG,CAAC,EAAE,EAAE,KAAK,GAAG;AACzF;",
  "names": []
}
