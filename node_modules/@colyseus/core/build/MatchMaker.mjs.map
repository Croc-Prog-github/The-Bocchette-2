{
  "version": 3,
  "sources": ["../src/MatchMaker.ts"],
  "sourcesContent": ["import { ErrorCode, Protocol } from './Protocol';\n\nimport { requestFromIPC, subscribeIPC } from './IPC';\n\nimport { Deferred, generateId, merge, REMOTE_ROOM_SHORT_TIMEOUT, retry } from './utils/Utils';\nimport { isDevMode, cacheRoomHistory, getPreviousProcessId, getRoomRestoreListKey, reloadFromCache } from './utils/DevMode';\n\nimport { RegisteredHandler } from './matchmaker/RegisteredHandler';\nimport { Room, RoomInternalState } from './Room';\n\nimport { LocalPresence } from './presence/LocalPresence';\nimport { Presence } from './presence/Presence';\n\nimport { debugAndPrintError, debugMatchMaking } from './Debug';\nimport { SeatReservationError } from './errors/SeatReservationError';\nimport { ServerError } from './errors/ServerError';\n\nimport { IRoomListingData, MatchMakerDriver, RoomListingData, LocalDriver } from './matchmaker/driver';\nimport controller from './matchmaker/controller';\n\nimport { logger } from './Logger';\nimport { Client } from './Transport';\nimport { Type } from './types';\nimport { getHostname } from \"./discovery\";\n\nexport { MatchMakerDriver, controller };\n\nexport type ClientOptions = any;\n\nexport interface SeatReservation {\n  sessionId: string;\n  room: RoomListingData;\n  devMode?: boolean;\n}\n\nconst handlers: {[id: string]: RegisteredHandler} = {};\nconst rooms: {[roomId: string]: Room} = {};\n\nexport let publicAddress: string;\nexport let processId: string;\nexport let presence: Presence;\nexport let driver: MatchMakerDriver;\n\nexport let isGracefullyShuttingDown: boolean;\nexport let onReady: Deferred;\n\nexport async function setup(\n  _presence?: Presence,\n  _driver?: MatchMakerDriver,\n  _publicAddress?: string,\n) {\n  onReady = new Deferred();\n  presence = _presence || new LocalPresence();\n  driver = _driver || new LocalDriver();\n  publicAddress = _publicAddress;\n\n  // devMode: try to retrieve previous processId\n  if (isDevMode) { processId = await getPreviousProcessId(await getHostname()); }\n\n  // ensure processId is set\n  if (!processId) { processId = generateId(); }\n\n  isGracefullyShuttingDown = false;\n\n  /**\n   * Subscribe to remote `handleCreateRoom` calls.\n   */\n  subscribeIPC(presence, processId, getProcessChannel(), (_, args) => {\n    return handleCreateRoom.apply(undefined, args);\n  });\n\n  await presence.hset(getRoomCountKey(), processId, '0');\n\n  if (isDevMode) {\n    await reloadFromCache();\n  }\n\n  onReady.resolve();\n}\n\n/**\n * Join or create into a room and return seat reservation\n */\nexport async function joinOrCreate(roomName: string, clientOptions: ClientOptions = {}) {\n  return await retry<Promise<SeatReservation>>(async () => {\n    let room = await findOneRoomAvailable(roomName, clientOptions);\n\n    if (!room) {\n      room = await createRoom(roomName, clientOptions);\n    }\n\n    return await reserveSeatFor(room, clientOptions);\n  }, 5, [SeatReservationError]);\n}\n\n/**\n * Create a room and return seat reservation\n */\nexport async function create(roomName: string, clientOptions: ClientOptions = {}) {\n  const room = await createRoom(roomName, clientOptions);\n  return reserveSeatFor(room, clientOptions);\n}\n\n/**\n * Join a room and return seat reservation\n */\nexport async function join(roomName: string, clientOptions: ClientOptions = {}) {\n  return await retry<Promise<SeatReservation>>(async () => {\n    const room = await findOneRoomAvailable(roomName, clientOptions);\n\n    if (!room) {\n      throw new ServerError(ErrorCode.MATCHMAKE_INVALID_CRITERIA, `no rooms found with provided criteria`);\n    }\n\n    return reserveSeatFor(room, clientOptions);\n  });\n}\n\n/**\n * Join a room by id and return seat reservation\n */\nexport async function reconnect(roomId: string, clientOptions: ClientOptions = {}) {\n  const room = await driver.findOne({ roomId });\n  if (!room) {\n    logger.info(`\u274C room \"${roomId}\" has been disposed. Did you missed .allowReconnection()?\\n\uD83D\uDC49 https://docs.colyseus.io/server/room/#allowreconnection-client-seconds`);\n    throw new ServerError(ErrorCode.MATCHMAKE_INVALID_ROOM_ID, `room \"${roomId}\" has been disposed.`);\n  }\n\n  // check for reconnection\n  const reconnectionToken = clientOptions.reconnectionToken;\n  if (!reconnectionToken) { throw new ServerError(ErrorCode.MATCHMAKE_UNHANDLED, `'reconnectionToken' must be provided for reconnection.`); }\n\n  // respond to re-connection!\n  const sessionId = await remoteRoomCall(room.roomId, 'checkReconnectionToken', [reconnectionToken]);\n  if (sessionId) {\n    return { room, sessionId };\n\n  } else {\n    logger.info(`\u274C reconnection token invalid or expired. Did you missed .allowReconnection()?\\n\uD83D\uDC49 https://docs.colyseus.io/server/room/#allowreconnection-client-seconds`);\n    throw new ServerError(ErrorCode.MATCHMAKE_EXPIRED, `reconnection token invalid or expired.`);\n  }\n}\n\n/**\n * Join a room by id and return client seat reservation. An exception is thrown if a room is not found for roomId.\n *\n * @param roomId - The Id of the specific room instance.\n * @param clientOptions - Options for the client seat reservation (for `onJoin`/`onAuth`)\n *\n * @returns Promise<SeatReservation> - A promise which contains `sessionId` and `RoomListingData`.\n */\nexport async function joinById(roomId: string, clientOptions: ClientOptions = {}) {\n  const room = await driver.findOne({ roomId });\n\n  if (!room) {\n    throw new ServerError(ErrorCode.MATCHMAKE_INVALID_ROOM_ID, `room \"${roomId}\" not found`);\n\n  } else if (room.locked) {\n    throw new ServerError(ErrorCode.MATCHMAKE_INVALID_ROOM_ID, `room \"${roomId}\" is locked`);\n  }\n\n  return reserveSeatFor(room, clientOptions);\n}\n\n/**\n * Perform a query for all cached rooms\n */\nexport async function query(conditions: Partial<IRoomListingData> = {}) {\n  return await driver.find(conditions);\n}\n\n/**\n * Find for a public and unlocked room available.\n *\n * @param roomName - The Id of the specific room.\n * @param clientOptions - Options for the client seat reservation (for `onJoin`/`onAuth`).\n *\n * @returns Promise<RoomListingData> - A promise contaning an object which includes room metadata and configurations.\n */\nexport async function findOneRoomAvailable(roomName: string, clientOptions: ClientOptions): Promise<RoomListingData> {\n  return await awaitRoomAvailable(roomName, async () => {\n    const handler = handlers[roomName];\n    if (!handler) {\n      throw new ServerError( ErrorCode.MATCHMAKE_NO_HANDLER, `provided room name \"${roomName}\" not defined`);\n    }\n\n    const roomQuery = driver.findOne({\n      locked: false,\n      name: roomName,\n      private: false,\n      ...handler.getFilterOptions(clientOptions),\n    });\n\n    if (handler.sortOptions) {\n      roomQuery.sort(handler.sortOptions);\n    }\n\n    return await roomQuery;\n  });\n}\n\n/**\n * Call a method or return a property on a remote room.\n *\n * @param roomId - The Id of the specific room instance.\n * @param method - Method or attribute to call or retrive.\n * @param args - Array of arguments for the method\n *\n * @returns Promise<any> - Returned value from the called or retrieved method/attribute.\n */\nexport async function remoteRoomCall<R= any>(\n  roomId: string,\n  method: string,\n  args?: any[],\n  rejectionTimeout = REMOTE_ROOM_SHORT_TIMEOUT,\n): Promise<R> {\n  const room = rooms[roomId];\n\n  if (!room) {\n    try {\n      return await requestFromIPC<R>(presence, getRoomChannel(roomId), method, args);\n\n    } catch (e) {\n      const request = `${method}${args && ' with args ' + JSON.stringify(args) || ''}`;\n      throw new ServerError(\n        ErrorCode.MATCHMAKE_UNHANDLED,\n        `remote room (${roomId}) timed out, requesting \"${request}\". (${rejectionTimeout}ms exceeded)`,\n      );\n    }\n\n  } else {\n    return (!args && typeof (room[method]) !== 'function')\n        ? room[method]\n        : (await room[method].apply(room, args && args.map((arg) => JSON.parse(JSON.stringify(arg)))));\n  }\n}\n\nexport function defineRoomType<T extends Type<Room>>(\n  name: string,\n  klass: T,\n  defaultOptions?: Parameters<NonNullable<InstanceType<T>['onCreate']>>[0],\n) {\n  const registeredHandler = new RegisteredHandler(klass, defaultOptions);\n\n  handlers[name] = registeredHandler;\n\n  if (!isDevMode) {\n    cleanupStaleRooms(name);\n  }\n\n  return registeredHandler;\n}\n\nexport function removeRoomType(name: string) {\n  delete handlers[name];\n\n  if (!isDevMode) {\n    cleanupStaleRooms(name);\n  }\n}\n\nexport function hasHandler(name: string) {\n  return handlers[ name ] !== undefined;\n}\n\n/**\n * Creates a new room.\n *\n * @param roomName - The identifier you defined on `gameServer.define()`\n * @param clientOptions - Options for `onCreate`\n *\n * @returns Promise<RoomListingData> - A promise contaning an object which includes room metadata and configurations.\n */\nexport async function createRoom(roomName: string, clientOptions: ClientOptions): Promise<RoomListingData> {\n  const roomsSpawnedByProcessId = await presence.hgetall(getRoomCountKey());\n\n  const processIdWithFewerRooms = (\n    Object.keys(roomsSpawnedByProcessId).sort((p1, p2) => {\n      return (Number(roomsSpawnedByProcessId[p1]) > Number(roomsSpawnedByProcessId[p2]))\n        ? 1\n        : -1;\n    })[0]\n  ) || processId;\n\n  let room: RoomListingData;\n  if (processIdWithFewerRooms === processId) {\n    // create the room on this process!\n    room = await handleCreateRoom(roomName, clientOptions);\n  } else {\n    // ask other process to create the room!\n    try {\n      room = await requestFromIPC<RoomListingData>(\n        presence,\n        getProcessChannel(processIdWithFewerRooms),\n        undefined,\n        [roomName, clientOptions],\n        REMOTE_ROOM_SHORT_TIMEOUT,\n      );\n\n    } catch (e) {\n      //\n      // clean-up possibly stale process from redis.\n      // when a process disconnects ungracefully, it may leave its previous processId under \"roomcount\"\n      // if the process is still alive, it will re-add itself shortly after the load-balancer selects it again.\n      //\n      await presence.hdel(getRoomCountKey(), processIdWithFewerRooms);\n\n      // if other process failed to respond, create the room on this process\n      debugAndPrintError(e);\n      room = await handleCreateRoom(roomName, clientOptions);\n    }\n  }\n\n  if (isDevMode) {\n    presence.hset(getRoomRestoreListKey(), room.roomId, JSON.stringify({\n      \"clientOptions\": clientOptions,\n      \"roomName\": roomName,\n      \"processId\": processId\n    }));\n  }\n\n  return room;\n}\n\nexport async function handleCreateRoom(roomName: string, clientOptions: ClientOptions, restoringRoomId?: string): Promise<RoomListingData> {\n  const registeredHandler = handlers[roomName];\n\n  if (!registeredHandler) {\n    throw new ServerError( ErrorCode.MATCHMAKE_NO_HANDLER, `provided room name \"${roomName}\" not defined`);\n  }\n\n  const room = new registeredHandler.klass();\n\n  // set room public attributes\n  if (restoringRoomId && isDevMode) {\n    room.roomId = restoringRoomId;\n\n  } else {\n    room.roomId = generateId();\n  }\n\n  room.roomName = roomName;\n  room.presence = presence;\n\n  const additionalListingData: any = registeredHandler.getFilterOptions(clientOptions);\n\n  // assign public host\n  if (publicAddress) {\n    additionalListingData.publicAddress = publicAddress;\n  }\n\n  // create a RoomCache reference.\n  room.listing = driver.createInstance({\n    name: roomName,\n    processId,\n    ...additionalListingData\n  });\n\n  if (room.onCreate) {\n    try {\n      await room.onCreate(merge({}, clientOptions, registeredHandler.options));\n\n      // increment amount of rooms this process is handling\n      presence.hincrby(getRoomCountKey(), processId, 1);\n\n    } catch (e) {\n      debugAndPrintError(e);\n      throw new ServerError(\n        e.code || ErrorCode.MATCHMAKE_UNHANDLED,\n        e.message,\n      );\n    }\n  }\n\n  room['_internalState'] = RoomInternalState.CREATED;\n\n  room.listing.roomId = room.roomId;\n  room.listing.maxClients = room.maxClients;\n\n  // imediatelly ask client to join the room\n  debugMatchMaking('spawning \\'%s\\', roomId: %s, processId: %s', roomName, room.roomId, processId);\n\n  room._events.on('lock', lockRoom.bind(this, room));\n  room._events.on('unlock', unlockRoom.bind(this, room));\n  room._events.on('join', onClientJoinRoom.bind(this, room));\n  room._events.on('leave', onClientLeaveRoom.bind(this, room));\n  room._events.once('dispose', disposeRoom.bind(this, roomName, room));\n  room._events.once('disconnect', () => room._events.removeAllListeners());\n\n  // room always start unlocked\n  await createRoomReferences(room, true);\n  await room.listing.save();\n\n  registeredHandler.emit('create', room);\n\n  return room.listing;\n}\n\nexport function getRoomById(roomId: string) {\n  return rooms[roomId];\n}\n\n/**\n * Disconnects every client on every room in the current process.\n */\nexport function disconnectAll(closeCode?: number) {\n  const promises: Array<Promise<any>> = [];\n\n  for (const roomId in rooms) {\n    if (!rooms.hasOwnProperty(roomId)) { continue; }\n    promises.push(rooms[roomId].disconnect(closeCode));\n  }\n\n  return promises;\n}\n\nexport async function gracefullyShutdown(): Promise<any> {\n  if (isGracefullyShuttingDown) {\n    return Promise.reject('already_shutting_down');\n  }\n\n  isGracefullyShuttingDown = true;\n\n  debugMatchMaking(`${processId} is shutting down!`);\n\n  if (isDevMode) {\n    await cacheRoomHistory(rooms);\n  }\n\n  // remove processId from room count key\n  presence.hdel(getRoomCountKey(), processId);\n\n  // unsubscribe from process id channel\n  presence.unsubscribe(getProcessChannel());\n\n  return Promise.all(disconnectAll(\n    (isDevMode)\n      ? Protocol.WS_CLOSE_DEVMODE_RESTART\n      : undefined\n  ));\n}\n\n/**\n * Reserve a seat for a client in a room\n */\nexport async function reserveSeatFor(room: RoomListingData, options: any) {\n  const sessionId: string = generateId();\n\n  debugMatchMaking(\n    'reserving seat. sessionId: \\'%s\\', roomId: \\'%s\\', processId: \\'%s\\'',\n    sessionId, room.roomId, processId,\n  );\n\n  let successfulSeatReservation: boolean;\n\n  try {\n    successfulSeatReservation = await remoteRoomCall(room.roomId, '_reserveSeat', [sessionId, options]);\n\n  } catch (e) {\n    debugMatchMaking(e);\n    successfulSeatReservation = false;\n  }\n\n  if (!successfulSeatReservation) {\n    throw new SeatReservationError(`${room.roomId} is already full.`);\n  }\n\n  const response: SeatReservation = { room, sessionId };\n\n  if (isDevMode) {\n    response.devMode = isDevMode;\n  }\n\n  return response;\n}\n\nasync function cleanupStaleRooms(roomName: string) {\n  //\n  // clean-up possibly stale room ids\n  // (ungraceful shutdowns using Redis can result on stale room ids still on memory.)\n  //\n  const cachedRooms = await driver.find({ name: roomName }, { _id: 1 });\n\n  // remove connecting counts\n  await presence.del(getHandlerConcurrencyKey(roomName));\n\n  await Promise.all(cachedRooms.map(async (room) => {\n    try {\n      // use hardcoded short timeout for cleaning up stale rooms.\n      await remoteRoomCall(room.roomId, 'roomId');\n\n    } catch (e) {\n      debugMatchMaking(`cleaning up stale room '${roomName}', roomId: ${room.roomId}`);\n      room.remove();\n    }\n  }));\n}\n\nasync function createRoomReferences(room: Room, init: boolean = false): Promise<boolean> {\n  rooms[room.roomId] = room;\n\n  if (init) {\n    await subscribeIPC(\n      presence,\n      processId,\n      getRoomChannel(room.roomId),\n      (method, args) => {\n        return (!args && typeof (room[method]) !== 'function')\n          ? room[method]\n          : room[method].apply(room, args);\n      },\n    );\n  }\n\n  return true;\n}\n\nasync function awaitRoomAvailable(roomToJoin: string, callback: Function): Promise<RoomListingData> {\n  return new Promise(async (resolve, reject) => {\n    const concurrencyKey = getHandlerConcurrencyKey(roomToJoin);\n    const concurrency = await presence.incr(concurrencyKey) - 1;\n\n    // avoid having too long timeout if 10+ clients ask to join at the same time\n    const concurrencyTimeout = Math.min(concurrency * 100, REMOTE_ROOM_SHORT_TIMEOUT);\n\n    if (concurrency > 0) {\n      debugMatchMaking(\n        'receiving %d concurrent requests for joining \\'%s\\' (waiting %d ms)',\n        concurrency, roomToJoin, concurrencyTimeout,\n      );\n    }\n\n    setTimeout(async () => {\n      try {\n        const result = await callback();\n        resolve(result);\n\n      } catch (e) {\n        reject(e);\n\n      } finally {\n        await presence.decr(concurrencyKey);\n      }\n    }, concurrencyTimeout);\n  });\n}\n\nfunction onClientJoinRoom(room: Room, client: Client) {\n  // increment global CCU\n  presence.incr(getGlobalCCUCounter());\n  handlers[room.roomName].emit('join', room, client);\n}\n\nfunction onClientLeaveRoom(room: Room, client: Client, willDispose: boolean) {\n  // decrement global CCU\n  presence.decr(getGlobalCCUCounter());\n  handlers[room.roomName].emit('leave', room, client, willDispose);\n}\n\nfunction lockRoom(room: Room): void {\n  // emit public event on registered handler\n  handlers[room.roomName].emit('lock', room);\n}\n\nasync function unlockRoom(room: Room) {\n  if (await createRoomReferences(room)) {\n    // emit public event on registered handler\n    handlers[room.roomName].emit('unlock', room);\n  }\n}\n\nasync function disposeRoom(roomName: string, room: Room) {\n  debugMatchMaking('disposing \\'%s\\' (%s) on processId \\'%s\\'', roomName, room.roomId, processId);\n\n  // decrease amount of rooms this process is handling\n  if (!isGracefullyShuttingDown) {\n    presence.hincrby(getRoomCountKey(), processId, -1);\n\n    // remove from devMode restore list\n    if (isDevMode) {\n      await presence.hdel(getRoomRestoreListKey(), room.roomId);\n    }\n  }\n\n  // emit disposal on registered session handler\n  handlers[roomName].emit('dispose', room);\n\n  // remove concurrency key\n  presence.del(getHandlerConcurrencyKey(roomName));\n\n  // unsubscribe from remote connections\n  presence.unsubscribe(getRoomChannel(room.roomId));\n\n  // remove actual room reference\n  delete rooms[room.roomId];\n}\n\n//\n// Presence keys\n//\nexport function getRoomCountKey() {\n  return 'roomcount';\n}\n\nfunction getRoomChannel(roomId: string) {\n  return `$${roomId}`;\n}\n\nfunction getHandlerConcurrencyKey(name: string) {\n  return `c:${name}`;\n}\n\nfunction getProcessChannel(id: string = processId) {\n  return `p:${id}`;\n}\n\nfunction getGlobalCCUCounter() {\n  return \"_ccu\";\n}\n"],
  "mappings": "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",
  "names": []
}
