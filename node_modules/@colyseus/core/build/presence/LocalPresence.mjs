import fs from "fs";
import path from "path";
import { EventEmitter } from "events";
import { spliceOne } from "../utils/Utils";
import { isDevMode } from "../utils/DevMode";
const DEVMODE_CACHE_FILE_PATH = path.resolve(".devmode.json");
class LocalPresence {
  constructor() {
    this.channels = new EventEmitter();
    this.data = {};
    this.hash = {};
    this.keys = {};
    this.subscriptions = {};
    this.timeouts = {};
    if (isDevMode && fs.existsSync(DEVMODE_CACHE_FILE_PATH)) {
      const cache = fs.readFileSync(DEVMODE_CACHE_FILE_PATH).toString("utf-8") || "{}";
      const parsed = JSON.parse(cache);
      if (parsed.data) {
        this.data = parsed.data;
      }
      if (parsed.hash) {
        this.hash = parsed.hash;
      }
      if (parsed.keys) {
        this.keys = parsed.keys;
      }
    }
  }
  subscribe(topic, callback) {
    if (!this.subscriptions[topic]) {
      this.subscriptions[topic] = [];
    }
    this.subscriptions[topic].push(callback);
    this.channels.on(topic, callback);
    return this;
  }
  unsubscribe(topic, callback) {
    const topicCallbacks = this.subscriptions[topic];
    if (!topicCallbacks) {
      return;
    }
    if (callback) {
      const idx = topicCallbacks.indexOf(callback);
      if (idx !== -1) {
        topicCallbacks.splice(idx, 1);
        this.channels.removeListener(topic, callback);
      }
      if (topicCallbacks.length === 0) {
        delete this.subscriptions[topic];
      }
    } else {
      topicCallbacks.forEach((cb) => this.channels.removeListener(topic, cb));
      delete this.subscriptions[topic];
    }
    return this;
  }
  publish(topic, data) {
    this.channels.emit(topic, data);
    return this;
  }
  async exists(roomId) {
    return this.channels.listenerCount(roomId) > 0;
  }
  set(key, value) {
    this.keys[key] = value;
  }
  setex(key, value, seconds) {
    if (this.timeouts[key]) {
      clearTimeout(this.timeouts[key]);
    }
    this.keys[key] = value;
    this.timeouts[key] = setTimeout(() => {
      delete this.keys[key];
      delete this.timeouts[key];
    }, seconds * 1e3);
  }
  get(key) {
    return this.keys[key];
  }
  del(key) {
    delete this.keys[key];
    delete this.data[key];
    delete this.hash[key];
  }
  sadd(key, value) {
    if (!this.data[key]) {
      this.data[key] = [];
    }
    if (this.data[key].indexOf(value) === -1) {
      this.data[key].push(value);
    }
  }
  async smembers(key) {
    return this.data[key] || [];
  }
  async sismember(key, field) {
    return this.data[key] && this.data[key].includes(field) ? 1 : 0;
  }
  srem(key, value) {
    if (this.data[key]) {
      spliceOne(this.data[key], this.data[key].indexOf(value));
    }
  }
  scard(key) {
    return (this.data[key] || []).length;
  }
  async sinter(...keys) {
    const intersection = {};
    for (let i = 0, l = keys.length; i < l; i++) {
      (await this.smembers(keys[i])).forEach((member) => {
        if (!intersection[member]) {
          intersection[member] = 0;
        }
        intersection[member]++;
      });
    }
    return Object.keys(intersection).reduce((prev, curr) => {
      if (intersection[curr] > 1) {
        prev.push(curr);
      }
      return prev;
    }, []);
  }
  hset(key, field, value) {
    if (!this.hash[key]) {
      this.hash[key] = {};
    }
    this.hash[key][field] = value;
  }
  hincrby(key, field, incrBy) {
    if (!this.hash[key]) {
      this.hash[key] = {};
    }
    let value = Number(this.hash[key][field] || "0");
    value += incrBy;
    this.hash[key][field] = value.toString();
    return value;
  }
  async hget(key, field) {
    return this.hash[key] && this.hash[key][field];
  }
  async hgetall(key) {
    return this.hash[key] || {};
  }
  hdel(key, field) {
    if (this.hash[key]) {
      delete this.hash[key][field];
    }
  }
  async hlen(key) {
    return this.hash[key] && Object.keys(this.hash[key]).length || 0;
  }
  async incr(key) {
    if (!this.keys[key]) {
      this.keys[key] = 0;
    }
    this.keys[key]++;
    return Promise.resolve(this.keys[key]);
  }
  async decr(key) {
    if (!this.keys[key]) {
      this.keys[key] = 0;
    }
    this.keys[key]--;
    return Promise.resolve(this.keys[key]);
  }
  shutdown() {
    if (isDevMode) {
      const cache = JSON.stringify({
        data: this.data,
        hash: this.hash,
        keys: this.keys
      });
      fs.writeFileSync(DEVMODE_CACHE_FILE_PATH, cache, { encoding: "utf-8" });
    }
  }
}
export {
  LocalPresence
};
