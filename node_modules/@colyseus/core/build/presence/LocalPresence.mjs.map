{
  "version": 3,
  "sources": ["../../src/presence/LocalPresence.ts"],
  "sourcesContent": ["import fs from 'fs';\nimport path from 'path';\n\nimport { EventEmitter } from 'events';\nimport { spliceOne } from '../utils/Utils.js';\nimport { Presence } from './Presence.js';\n\nimport { isDevMode } from '../utils/DevMode.js';\n\ntype Callback = (...args: any[]) => void;\n\nconst DEVMODE_CACHE_FILE_PATH = path.resolve(\".devmode.json\");\n\nexport class LocalPresence implements Presence {\n    public channels = new EventEmitter();\n\n    public data: {[roomName: string]: string[]} = {};\n    public hash: {[roomName: string]: {[key: string]: string}} = {};\n\n    public keys: {[name: string]: string | number} = {};\n\n    private timeouts: {[name: string]: NodeJS.Timeout} = {};\n\n    constructor() {\n      //\n      // reload from local cache on devMode\n      //\n      if (\n        isDevMode &&\n        fs.existsSync(DEVMODE_CACHE_FILE_PATH)\n      ) {\n        const cache = fs.readFileSync(DEVMODE_CACHE_FILE_PATH).toString('utf-8') || \"{}\";\n        const parsed = JSON.parse(cache);\n        if (parsed.data) { this.data = parsed.data; }\n        if (parsed.hash) { this.hash = parsed.hash; }\n        if (parsed.keys) { this.keys = parsed.keys; }\n      }\n    }\n\n    public subscribe(topic: string, callback: (...args: any[]) => void) {\n        this.channels.on(topic, callback);\n        return this;\n    }\n\n    public unsubscribe(topic: string, callback?: Callback) {\n        if (callback)  {\n            this.channels.removeListener(topic, callback);\n\n        } else {\n            this.channels.removeAllListeners(topic);\n        }\n\n        return this;\n    }\n\n    public publish(topic: string, data: any) {\n        this.channels.emit(topic, data);\n        return this;\n    }\n\n    public async exists(key: string): Promise<boolean> {\n        return (\n          this.keys[key] !== undefined ||\n          this.data[key] !== undefined ||\n          this.hash[key] !== undefined\n        );\n    }\n\n    public set(key: string, value: string) {\n        this.keys[key] = value;\n    }\n\n    public setex(key: string, value: string, seconds: number) {\n        this.keys[key] = value;\n        this.expire(key, seconds);\n    }\n\n    public expire(key: string, seconds: number) {\n        // ensure previous timeout is clear before setting another one.\n        if (this.timeouts[key]) {\n            clearTimeout(this.timeouts[key]);\n        }\n        this.timeouts[key] = setTimeout(() => {\n            delete this.keys[key];\n            delete this.timeouts[key];\n        }, seconds * 1000);\n    }\n\n    public get(key: string) {\n        return this.keys[key];\n    }\n\n    public del(key: string) {\n        delete this.keys[key];\n        delete this.data[key];\n        delete this.hash[key];\n    }\n\n    public sadd(key: string, value: any) {\n        if (!this.data[key]) {\n            this.data[key] = [];\n        }\n\n        if (this.data[key].indexOf(value) === -1) {\n            this.data[key].push(value);\n        }\n    }\n\n    public async smembers(key: string): Promise<string[]> {\n        return this.data[key] || [];\n    }\n\n    public async sismember(key: string, field: string) {\n        return this.data[key] && this.data[key].includes(field) ? 1 : 0;\n    }\n\n    public srem(key: string, value: any) {\n        if (this.data[key]) {\n            spliceOne(this.data[key], this.data[key].indexOf(value));\n        }\n    }\n\n    public scard(key: string) {\n        return (this.data[key] || []).length;\n    }\n\n    public async sinter(...keys: string[]) {\n      const intersection: {[value: string]: number} = {};\n\n      for (let i = 0, l = keys.length; i < l; i++) {\n        (await this.smembers(keys[i])).forEach((member) => {\n          if (!intersection[member]) {\n            intersection[member] = 0;\n          }\n\n          intersection[member]++;\n        });\n      }\n\n      return Object.keys(intersection).reduce((prev, curr) => {\n        if (intersection[curr] > 1) {\n          prev.push(curr);\n        }\n        return prev;\n      }, []);\n    }\n\n    public hset(key: string, field: string, value: string) {\n        if (!this.hash[key]) { this.hash[key] = {}; }\n        this.hash[key][field] = value;\n    }\n\n    public hincrby(key: string, field: string, incrBy: number) {\n        if (!this.hash[key]) { this.hash[key] = {}; }\n        let value = Number(this.hash[key][field] || '0');\n        value += incrBy;\n        this.hash[key][field] = value.toString();\n        return value;\n    }\n\n    public hincrbyex(key: string, field: string, incrBy: number, expireInSeconds: number) {\n        if (!this.hash[key]) { this.hash[key] = {}; }\n        let value = Number(this.hash[key][field] || '0');\n        value += incrBy;\n        this.hash[key][field] = value.toString();\n        this.setex(key, field, expireInSeconds);\n        return value;\n    }\n\n    public async hget(key: string, field: string) {\n        return this.hash[key] && this.hash[key][field];\n    }\n\n    public async hgetall(key: string) {\n        return this.hash[key] || {};\n    }\n\n    public hdel(key: string, field: any) {\n        const success = this.hash?.[key]?.[field] !== undefined;\n        if (success) {\n            delete this.hash[key][field];\n        }\n        return success;\n    }\n\n    public async hlen(key: string) {\n        return this.hash[key] && Object.keys(this.hash[key]).length || 0;\n    }\n\n    public async incr(key: string) {\n        if (!this.keys[key]) {\n            this.keys[key] = 0;\n        }\n        (this.keys[key] as number)++;\n        return Promise.resolve(this.keys[key] as number);\n    }\n\n    public async decr(key: string) {\n        if (!this.keys[key]) {\n            this.keys[key] = 0;\n        }\n        (this.keys[key] as number)--;\n        return Promise.resolve(this.keys[key] as number);\n    }\n\n    public llen(key: string): number {\n      return (this.data[key] && this.data[key].length) || 0;\n    }\n\n    public rpush(key: string, ...values: string[]): number {\n      if (!this.data[key]) { this.data[key] = []; }\n\n      let lastLength: number = 0;\n\n      values.forEach(value => {\n        lastLength = this.data[key].push(value);\n      });\n\n      return lastLength;\n    }\n\n    public lpush(key: string, ...values: string[]): number {\n      if (!this.data[key]) { this.data[key] = []; }\n\n      let lastLength: number = 0;\n\n      values.forEach(value => {\n        lastLength = this.data[key].unshift(value);\n      });\n\n      return lastLength;\n    }\n\n\n    public lpop(key: string): string {\n      return Array.isArray(this.data[key]) && this.data[key].shift();\n    }\n\n    public rpop(key: string): string {\n      return this.data[key].pop();\n    }\n\n    public brpop(...args: [...keys: string[], timeoutInSeconds: number]): Promise<[string, string] | null> {\n      const keys = args.slice(0, -2) as string[];\n      const timeoutInSeconds = args[args.length - 1] as number;\n\n      const getFirstPopulated = (): [string, string] | null => {\n        const keyWithValue = keys.find(key => this.data[key] && this.data[key].length > 0);\n        if (keyWithValue) {\n          return [keyWithValue, this.data[keyWithValue].pop()];\n        } else {\n          return null;\n        }\n      }\n\n      const firstPopulated = getFirstPopulated();\n\n      if (firstPopulated) {\n        // return first populated key + item\n        return Promise.resolve(firstPopulated);\n\n      } else {\n        // 8 retries per second\n        const maxRetries = timeoutInSeconds * 8;\n\n        let tries = 0;\n        return new Promise((resolve) => {\n          const interval = setInterval(() => {\n            tries++;\n\n            const firstPopulated = getFirstPopulated();\n            if (firstPopulated) {\n              clearInterval(interval);\n              return resolve(firstPopulated);\n\n            } else if (tries >= maxRetries) {\n              clearInterval(interval);\n              return resolve(undefined);\n            }\n\n          }, (timeoutInSeconds * 1000) / maxRetries);\n        });\n      }\n    }\n\n    public shutdown() {\n      if (isDevMode) {\n        const cache = JSON.stringify({\n          data: this.data,\n          hash: this.hash,\n          keys: this.keys\n        });\n        fs.writeFileSync(DEVMODE_CACHE_FILE_PATH, cache, { encoding: \"utf-8\" });\n      }\n    }\n\n}\n"],
  "mappings": "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",
  "names": ["firstPopulated"]
}
