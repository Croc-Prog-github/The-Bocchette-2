import { EventEmitter } from 'events';
import { Presence } from './Presence.js';
type Callback = (...args: any[]) => void;
export declare class LocalPresence implements Presence {
    channels: EventEmitter<[never]>;
    data: {
        [roomName: string]: string[];
    };
    hash: {
        [roomName: string]: {
            [key: string]: string;
        };
    };
    keys: {
        [name: string]: string | number;
    };
    private timeouts;
    constructor();
    subscribe(topic: string, callback: (...args: any[]) => void): this;
    unsubscribe(topic: string, callback?: Callback): this;
    publish(topic: string, data: any): this;
    exists(key: string): Promise<boolean>;
    set(key: string, value: string): void;
    setex(key: string, value: string, seconds: number): void;
    expire(key: string, seconds: number): void;
    get(key: string): string | number;
    del(key: string): void;
    sadd(key: string, value: any): void;
    smembers(key: string): Promise<string[]>;
    sismember(key: string, field: string): Promise<0 | 1>;
    srem(key: string, value: any): void;
    scard(key: string): number;
    sinter(...keys: string[]): Promise<any[]>;
    hset(key: string, field: string, value: string): void;
    hincrby(key: string, field: string, incrBy: number): number;
    hincrbyex(key: string, field: string, incrBy: number, expireInSeconds: number): number;
    hget(key: string, field: string): Promise<string>;
    hgetall(key: string): Promise<{
        [key: string]: string;
    }>;
    hdel(key: string, field: any): boolean;
    hlen(key: string): Promise<number>;
    incr(key: string): Promise<number>;
    decr(key: string): Promise<number>;
    llen(key: string): number;
    rpush(key: string, ...values: string[]): number;
    lpush(key: string, ...values: string[]): number;
    lpop(key: string): string;
    rpop(key: string): string;
    brpop(...args: [...keys: string[], timeoutInSeconds: number]): Promise<[string, string] | null>;
    shutdown(): void;
}
export {};
