var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var LocalPresence_exports = {};
__export(LocalPresence_exports, {
  LocalPresence: () => LocalPresence
});
module.exports = __toCommonJS(LocalPresence_exports);
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_events = require("events");
var import_Utils = require("../utils/Utils");
var import_DevMode = require("../utils/DevMode");
const DEVMODE_CACHE_FILE_PATH = import_path.default.resolve(".devmode.json");
class LocalPresence {
  constructor() {
    this.channels = new import_events.EventEmitter();
    this.data = {};
    this.hash = {};
    this.keys = {};
    this.subscriptions = {};
    this.timeouts = {};
    if (import_DevMode.isDevMode && import_fs.default.existsSync(DEVMODE_CACHE_FILE_PATH)) {
      const cache = import_fs.default.readFileSync(DEVMODE_CACHE_FILE_PATH).toString("utf-8") || "{}";
      const parsed = JSON.parse(cache);
      if (parsed.data) {
        this.data = parsed.data;
      }
      if (parsed.hash) {
        this.hash = parsed.hash;
      }
      if (parsed.keys) {
        this.keys = parsed.keys;
      }
    }
  }
  subscribe(topic, callback) {
    if (!this.subscriptions[topic]) {
      this.subscriptions[topic] = [];
    }
    this.subscriptions[topic].push(callback);
    this.channels.on(topic, callback);
    return this;
  }
  unsubscribe(topic, callback) {
    const topicCallbacks = this.subscriptions[topic];
    if (!topicCallbacks) {
      return;
    }
    if (callback) {
      const idx = topicCallbacks.indexOf(callback);
      if (idx !== -1) {
        topicCallbacks.splice(idx, 1);
        this.channels.removeListener(topic, callback);
      }
      if (topicCallbacks.length === 0) {
        delete this.subscriptions[topic];
      }
    } else {
      topicCallbacks.forEach((cb) => this.channels.removeListener(topic, cb));
      delete this.subscriptions[topic];
    }
    return this;
  }
  publish(topic, data) {
    this.channels.emit(topic, data);
    return this;
  }
  async exists(roomId) {
    return this.channels.listenerCount(roomId) > 0;
  }
  set(key, value) {
    this.keys[key] = value;
  }
  setex(key, value, seconds) {
    if (this.timeouts[key]) {
      clearTimeout(this.timeouts[key]);
    }
    this.keys[key] = value;
    this.timeouts[key] = setTimeout(() => {
      delete this.keys[key];
      delete this.timeouts[key];
    }, seconds * 1e3);
  }
  get(key) {
    return this.keys[key];
  }
  del(key) {
    delete this.keys[key];
    delete this.data[key];
    delete this.hash[key];
  }
  sadd(key, value) {
    if (!this.data[key]) {
      this.data[key] = [];
    }
    if (this.data[key].indexOf(value) === -1) {
      this.data[key].push(value);
    }
  }
  async smembers(key) {
    return this.data[key] || [];
  }
  async sismember(key, field) {
    return this.data[key] && this.data[key].includes(field) ? 1 : 0;
  }
  srem(key, value) {
    if (this.data[key]) {
      (0, import_Utils.spliceOne)(this.data[key], this.data[key].indexOf(value));
    }
  }
  scard(key) {
    return (this.data[key] || []).length;
  }
  async sinter(...keys) {
    const intersection = {};
    for (let i = 0, l = keys.length; i < l; i++) {
      (await this.smembers(keys[i])).forEach((member) => {
        if (!intersection[member]) {
          intersection[member] = 0;
        }
        intersection[member]++;
      });
    }
    return Object.keys(intersection).reduce((prev, curr) => {
      if (intersection[curr] > 1) {
        prev.push(curr);
      }
      return prev;
    }, []);
  }
  hset(key, field, value) {
    if (!this.hash[key]) {
      this.hash[key] = {};
    }
    this.hash[key][field] = value;
  }
  hincrby(key, field, incrBy) {
    if (!this.hash[key]) {
      this.hash[key] = {};
    }
    let value = Number(this.hash[key][field] || "0");
    value += incrBy;
    this.hash[key][field] = value.toString();
    return value;
  }
  async hget(key, field) {
    return this.hash[key] && this.hash[key][field];
  }
  async hgetall(key) {
    return this.hash[key] || {};
  }
  hdel(key, field) {
    if (this.hash[key]) {
      delete this.hash[key][field];
    }
  }
  async hlen(key) {
    return this.hash[key] && Object.keys(this.hash[key]).length || 0;
  }
  async incr(key) {
    if (!this.keys[key]) {
      this.keys[key] = 0;
    }
    this.keys[key]++;
    return Promise.resolve(this.keys[key]);
  }
  async decr(key) {
    if (!this.keys[key]) {
      this.keys[key] = 0;
    }
    this.keys[key]--;
    return Promise.resolve(this.keys[key]);
  }
  shutdown() {
    if (import_DevMode.isDevMode) {
      const cache = JSON.stringify({
        data: this.data,
        hash: this.hash,
        keys: this.keys
      });
      import_fs.default.writeFileSync(DEVMODE_CACHE_FILE_PATH, cache, { encoding: "utf-8" });
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  LocalPresence
});
