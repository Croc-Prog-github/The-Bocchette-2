var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var SchemaSerializer_exports = {};
__export(SchemaSerializer_exports, {
  SchemaSerializer: () => SchemaSerializer
});
module.exports = __toCommonJS(SchemaSerializer_exports);
var import_schema = require("@colyseus/schema");
var import_Debug = require("../Debug.js");
var import_Protocol = require("../Protocol.js");
var import_Transport = require("../Transport.js");
const SHARED_VIEW = {};
class SchemaSerializer {
  constructor() {
    this.id = "schema";
    this.hasFilters = false;
    // flag to avoid re-encoding full state if no changes were made
    this.needFullEncode = true;
    // TODO: make this optional. allocating a new buffer for each room may not be always necessary.
    this.fullEncodeBuffer = Buffer.allocUnsafe(import_schema.Encoder.BUFFER_SIZE);
    this.sharedOffsetCache = { offset: 0 };
  }
  reset(newState) {
    this.encoder = new import_schema.Encoder(newState);
    this.hasFilters = this.encoder.context.hasFilters;
    this.fullEncodeBuffer[0] = import_Protocol.Protocol.ROOM_STATE;
    if (this.hasFilters) {
      this.views = /* @__PURE__ */ new Map();
    }
  }
  getFullState(client) {
    if (this.needFullEncode || this.encoder.root.changes.length > 0) {
      this.sharedOffsetCache = { offset: 1 };
      this.fullEncodeCache = this.encoder.encodeAll(this.sharedOffsetCache, this.fullEncodeBuffer);
      this.needFullEncode = false;
    }
    if (this.hasFilters && client?.view) {
      return this.encoder.encodeAllView(
        client.view,
        this.sharedOffsetCache.offset,
        { ...this.sharedOffsetCache },
        this.fullEncodeBuffer
      );
    } else {
      return this.fullEncodeCache;
    }
  }
  applyPatches(clients) {
    let numClients = clients.length;
    if (numClients == 0 || !this.encoder.hasChanges) {
      return false;
    }
    this.needFullEncode = true;
    if (import_Debug.debugPatch.enabled) {
      import_Debug.debugPatch.dumpChanges = (0, import_schema.dumpChanges)(this.encoder.state);
    }
    const it = { offset: 1 };
    this.encoder.sharedBuffer[0] = import_Protocol.Protocol.ROOM_STATE_PATCH;
    const encodedChanges = this.encoder.encode(it);
    if (!this.hasFilters) {
      while (numClients--) {
        const client = clients[numClients];
        if (client.state !== import_Transport.ClientState.JOINED) {
          continue;
        }
        client.raw(encodedChanges);
      }
    } else {
      const sharedOffset = it.offset;
      while (numClients--) {
        const client = clients[numClients];
        if (client.state !== import_Transport.ClientState.JOINED) {
          continue;
        }
        const view = client.view || SHARED_VIEW;
        let encodedView = this.views.get(view);
        if (encodedView === void 0) {
          encodedView = view === SHARED_VIEW ? encodedChanges : this.encoder.encodeView(client.view, sharedOffset, it);
          this.views.set(view, encodedView);
        }
        client.raw(encodedView);
      }
      this.views.clear();
    }
    this.encoder.discardChanges();
    if (import_Debug.debugPatch.enabled) {
      (0, import_Debug.debugPatch)(
        "%d bytes sent to %d clients, %j",
        encodedChanges.length,
        clients.length,
        import_Debug.debugPatch.dumpChanges
      );
    }
    return true;
  }
  handshake() {
    if (!this.handshakeCache) {
      this.handshakeCache = this.encoder.state && import_schema.Reflection.encode(this.encoder);
    }
    return this.handshakeCache;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SchemaSerializer
});
