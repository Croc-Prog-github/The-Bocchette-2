var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  RedisPresence: () => RedisPresence
});
module.exports = __toCommonJS(src_exports);
var import_ioredis = __toESM(require("ioredis"));
class RedisPresence {
  constructor(options, clusterOptions) {
    this.subscriptions = {};
    this.handleSubscription = (channel, message) => {
      if (this.subscriptions[channel]) {
        for (let i = 0, l = this.subscriptions[channel].length; i < l; i++) {
          this.subscriptions[channel][i](JSON.parse(message));
        }
      }
    };
    if (Array.isArray(options)) {
      this.sub = new import_ioredis.Cluster(options, clusterOptions);
      this.pub = new import_ioredis.Cluster(options, clusterOptions);
    } else {
      this.sub = new import_ioredis.default(options);
      this.pub = new import_ioredis.default(options);
    }
    this.sub.setMaxListeners(0);
  }
  async subscribe(topic, callback) {
    if (!this.subscriptions[topic]) {
      this.subscriptions[topic] = [];
    }
    this.subscriptions[topic].push(callback);
    if (this.sub.listeners("message").length === 0) {
      this.sub.on("message", this.handleSubscription);
    }
    await this.sub.subscribe(topic);
    return this;
  }
  async unsubscribe(topic, callback) {
    const topicCallbacks = this.subscriptions[topic];
    if (!topicCallbacks) {
      return;
    }
    if (callback) {
      const index = topicCallbacks.indexOf(callback);
      topicCallbacks.splice(index, 1);
    } else {
      this.subscriptions[topic] = [];
    }
    if (this.subscriptions[topic].length === 0) {
      delete this.subscriptions[topic];
      await this.sub.unsubscribe(topic);
    }
    return this;
  }
  async publish(topic, data) {
    if (data === void 0) {
      data = false;
    }
    await this.pub.publish(topic, JSON.stringify(data));
  }
  async exists(roomId) {
    return (await this.pub.pubsub("channels", roomId)).length > 0;
  }
  async set(key, value) {
    return new Promise((resolve) => this.pub.set(key, value, resolve));
  }
  async setex(key, value, seconds) {
    return new Promise((resolve) => this.pub.setex(key, seconds, value, resolve));
  }
  async get(key) {
    return new Promise((resolve, reject) => {
      this.pub.get(key, (err, data) => {
        if (err) {
          return reject(err);
        }
        resolve(data);
      });
    });
  }
  async del(roomId) {
    return new Promise((resolve) => {
      this.pub.del(roomId, resolve);
    });
  }
  async sadd(key, value) {
    return new Promise((resolve) => {
      this.pub.sadd(key, value, resolve);
    });
  }
  async smembers(key) {
    return await this.pub.smembers(key);
  }
  async sismember(key, field) {
    return await this.pub.sismember(key, field);
  }
  async srem(key, value) {
    return await this.pub.srem(key, value);
  }
  async scard(key) {
    return await this.pub.scard(key);
  }
  async sinter(...keys) {
    return await this.pub.sinter(...keys);
  }
  async hset(key, field, value) {
    return await this.pub.hset(key, field, value);
  }
  async hincrby(key, field, value) {
    return new Promise((resolve, reject) => {
      this.pub.hincrby(key, field, value, (err, result) => {
        if (err)
          return reject(err);
        resolve(result);
      });
    });
  }
  async hget(key, field) {
    return await this.pub.hget(key, field);
  }
  async hgetall(key) {
    return await this.pub.hgetall(key);
  }
  async hdel(key, field) {
    return await this.pub.hdel(key, field);
  }
  async hlen(key) {
    return await this.pub.hlen(key);
  }
  async incr(key) {
    return await this.pub.incr(key);
  }
  async decr(key) {
    return await this.pub.decr(key);
  }
  shutdown() {
    this.sub.quit();
    this.pub.quit();
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  RedisPresence
});
