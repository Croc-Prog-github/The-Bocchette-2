// packages/presence/redis-presence/src/index.ts
import Redis, { Cluster } from "ioredis";
import EventEmitter from "events";
var RedisPresence = class {
  constructor(options, clusterOptions) {
    this.channels = new EventEmitter();
    this.handleSubscription = (channel, message) => {
      this.channels.emit(channel, JSON.parse(message));
    };
    if (Array.isArray(options)) {
      this.sub = new Cluster(options, clusterOptions);
      this.pub = new Cluster(options, clusterOptions);
    } else {
      this.sub = new Redis(options);
      this.pub = new Redis(options);
    }
    this.sub.setMaxListeners(0);
  }
  async subscribe(topic, callback) {
    this.channels.addListener(topic, callback);
    if (this.sub.listeners("message").length === 0) {
      this.sub.on("message", this.handleSubscription);
    }
    await this.sub.subscribe(topic);
    return this;
  }
  async unsubscribe(topic, callback) {
    if (callback) {
      this.channels.removeListener(topic, callback);
    } else {
      this.channels.removeAllListeners(topic);
    }
    if (this.channels.listenerCount(topic) === 0) {
      await this.sub.unsubscribe(topic);
    }
    return this;
  }
  async publish(topic, data) {
    if (data === void 0) {
      data = false;
    }
    await this.pub.publish(topic, JSON.stringify(data));
  }
  async exists(key) {
    return await this.pub.exists(key) === 1;
  }
  async set(key, value) {
    return new Promise((resolve) => this.pub.set(key, value, resolve));
  }
  async setex(key, value, seconds) {
    return new Promise((resolve) => this.pub.setex(key, seconds, value, resolve));
  }
  async expire(key, seconds) {
    return new Promise((resolve) => this.pub.expire(key, seconds, resolve));
  }
  async get(key) {
    return new Promise((resolve, reject) => {
      this.pub.get(key, (err, data) => {
        if (err) {
          return reject(err);
        }
        resolve(data);
      });
    });
  }
  async del(roomId) {
    return new Promise((resolve) => {
      this.pub.del(roomId, resolve);
    });
  }
  async sadd(key, value) {
    return new Promise((resolve) => {
      this.pub.sadd(key, value, resolve);
    });
  }
  async smembers(key) {
    return await this.pub.smembers(key);
  }
  async sismember(key, field) {
    return await this.pub.sismember(key, field);
  }
  async srem(key, value) {
    return await this.pub.srem(key, value);
  }
  async scard(key) {
    return await this.pub.scard(key);
  }
  async sinter(...keys) {
    return await this.pub.sinter(...keys);
  }
  async hset(key, field, value) {
    return await this.pub.hset(key, field, value);
  }
  async hincrby(key, field, value) {
    return new Promise((resolve, reject) => {
      this.pub.hincrby(key, field, value, (err, result) => {
        if (err) return reject(err);
        resolve(result);
      });
    });
  }
  async hincrbyex(key, field, value, expireInSeconds) {
    return new Promise((resolve, reject) => {
      this.pub.multi().hincrby(key, field, value).expire(key, expireInSeconds).exec((err, results) => {
        if (err) return reject(err);
        resolve(results[0][1]);
      });
    });
  }
  async hget(key, field) {
    return await this.pub.hget(key, field);
  }
  async hgetall(key) {
    return await this.pub.hgetall(key);
  }
  async hdel(key, field) {
    return await this.pub.hdel(key, field) > 0;
  }
  async hlen(key) {
    return await this.pub.hlen(key);
  }
  async incr(key) {
    return await this.pub.incr(key);
  }
  async decr(key) {
    return await this.pub.decr(key);
  }
  async llen(key) {
    return await this.pub.llen(key);
  }
  async rpush(key, value) {
    return await this.pub.rpush(key, value);
  }
  async lpush(key, value) {
    return await this.pub.lpush(key, value);
  }
  async rpop(key) {
    return await this.pub.rpop(key);
  }
  async lpop(key) {
    return await this.pub.lpop(key);
  }
  async brpop(...args) {
    return await this.pub.brpop.apply(this.pub, args);
  }
  shutdown() {
    this.sub.quit();
    this.pub.quit();
  }
};
export {
  RedisPresence
};
