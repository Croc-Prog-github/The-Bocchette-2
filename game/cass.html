<!DOCTYPE html>
<html>
  <head>
    <title>The Bocchette - Ricompenze</title>
    <!-- START <meta> -->
    <meta charset="UTF-8">
    <!-- END <meta> -->

    <!-- Content -->
    <script>
      let Ncass = 1;
      if (Ncass <= 0) {
        window.location.href = '/game/home.html';
      }
    </script>
  </head>
  <body style="font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif; background-color: #316f87;" onload="">

    <div class="div-container">
      <div class="item">200 Banconote</div>
      <div class="item">50 Gemme</div>
      <div class="item">Tecnica comune</div>
      <div class="item">Tecniche rare</div>
      <div class="item">Tecniche Mitiche</div>
      <div class="item">Tecniche leggendarie</div>
      <div class="item">Tecniche finali</div>
    </div>
    <div class="rectangle"></div>

  </body>
</html>

<script> //Probabilità per le ricompensa
  // Il codice calcola la somma totale delle probabilità, genera un numero casuale tra 0 e la somma totale, e quindi usa una serie di istruzioni if per determinare l'oggetto basato sulla probabilità. L'output del codice sarà una stringa che rappresenta l'oggetto generato casualmente.
  function randomObject() {
    const probabilita = {
      banconote: 30,
      gemme: 25,
      tecnicheComuni: 60,
      tecnicheRare: 39,
      tecnicheMitiche: 24,
      tecnicheLeggendarie: 20,
      tecnicheFinali: 15,
    };

    const total = Object.values(probabilita).reduce((acc, val) => acc + val, 0);
    const random = Math.floor(Math.random() * total);
    let count = 0;

    if (random < probabilita.banconote) {
      return "banconote";
    } else {
      count += probabilita.banconote;
    }

    if (random < count + probabilita.gemme) {
      return "gemme";
    } else {
      count += probabilita.gemme;
    }

    if (random < count + probabilita.tecnicheComuni) {
      return "tecniche comuni";
    } else {
      count += probabilita.tecnicheComuni;
    }

    if (random < count + probabilita.tecnicheRare) {
      return "tecniche rare";
    } else {
      count += probabilita.tecnicheRare;
    }

    if (random < count + probabilita.tecnicheMitiche) {
      return "tecniche mitiche";
    } else {
      count += probabilita.tecnicheMitiche;
    }

    if (random < count + probabilita.tecnicheLeggendarie) {
      return "tecniche leggendarie";
    } else {
      count += probabilita.tecnicheLeggendarie;
    }

    if (random < count + probabilita.tecnicheFinali) {
      return "tecniche finali";
    } else {
      count += probabilita.tecnicheFinali;
    }
  }

</script>

<style>
.div-container {
  width: 100%;
  height: 50px;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  overflow: hidden;
}

.item {
  white-space: nowrap;
}

.rectangle {
  width: 150px;
  height: 50px;
  background: transparent;
  border: solid 5px;
  margin-top: -3.8%;
  margin-left: 42%;
}
</style>

<!--
<script>
const container = document.querySelector('.div-container');
const items = document.querySelectorAll('.item');
const speed = 5;

let pos = 0;
let delay = 0;
let itemIndex = 0;

function animate() {
  pos -= speed;
  container.style.transform = `translateX(${pos}px)`;

  if (pos < -(items[itemIndex].offsetWidth)) {
    pos += items[itemIndex].offsetWidth;
    container.appendChild(items[itemIndex]);
    itemIndex++;
    if (itemIndex >= items.length) {
      itemIndex = 0;
    }
  }

  if (delay > 0) {
    delay *= 0.97;
    setTimeout(animate, delay);
  } else {
    console.log("message");
  }
}

function startAnimation() {
  pos = 0;
  delay = 150;
  itemIndex = 0;
  container.style.transform = `translateX(${pos}px)`;
  setTimeout(animate, delay);
}

startAnimation();
</script>
-->

<script>
  let items = document.querySelectorAll('.item');
  //items = transform.style.translateX("-10px");
  //items.style.transform = 'translateX(-10px)';
</script>