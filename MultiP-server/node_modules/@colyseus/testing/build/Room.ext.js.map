{
  "version": 3,
  "sources": ["../src/Room.ext.ts"],
  "sourcesContent": ["/**\n * Room.ts augmentations\n * Monkey-patches some Room methods to improve the testing experience.\n */\n\nimport { Deferred, Room, Client } from \"@colyseus/core\";\nimport { Room as ClientRoom } from \"colyseus.js\";\n\n// import timers from \"timers/promises\";\n\n// ----------------------------------------------------------------------------------------\n// SERVER-SIDE EXTENSIONS\n// ----------------------------------------------------------------------------------------\n\ndeclare module \"@colyseus/core\" {\n  interface Room {\n    waitForMessage(messageType: string): Promise<[Client, any]>;\n    waitForNextMessage(additionalDelay?: number): Promise<void>;\n    waitForNextPatch(): Promise<void>;\n    waitForNextSimulationTick(): Promise<void>;\n    _waitingForMessage: [number, Deferred];\n    _waitingForPatch: [number, Deferred];\n  }\n}\n\n/*\n * Wait until receive message\n */\nconst _originalOnMessage = Room.prototype['_onMessage'];\nRoom.prototype['_onMessage'] = function(this: Room) {\n  _originalOnMessage.apply(this, arguments);\n  if (this._waitingForMessage) {\n    setTimeout(() => this._waitingForMessage[1].resolve(), this._waitingForMessage[0]);\n  }\n};\nRoom.prototype.waitForNextMessage = async function(this: Room, additionalDelay: number = 0) {\n  this._waitingForMessage = [additionalDelay, new Deferred()];\n  return this._waitingForMessage[1];\n}\n\nRoom.prototype.waitForMessage = async function(this: Room, type: string, rejectTimeout: number = 3000) {\n  const originalMessageHandler = this['onMessageHandlers'][type] || (() => {});\n  const room = this;\n\n  return new Promise<[Client, any]>((resolve, reject) => {\n    const rejectionTimeout = setTimeout(() => reject(new Error(`message '${type}' was not called. timed out (${rejectTimeout}ms)`)), rejectTimeout);\n\n    room['onMessageHandlers'][type] = async function (client, message) {\n      // clear rejection timeout\n      clearTimeout(rejectionTimeout);\n\n      // call original handler\n      await originalMessageHandler.apply(room, arguments);\n\n      // revert to original message handler\n      room['onMessageHandlers'][type] = originalMessageHandler;\n\n      // resolves waitForMessage promise.\n      resolve([client, message]);\n    }\n  });\n}\n\n/**\n * Wait next simulation tick\n */\nRoom.prototype.waitForNextSimulationTick = async function(this: Room) {\n  if (this['_simulationInterval']) {\n    const milliseconds = this['_simulationInterval']['_idleTimeout'];\n    return new Promise((resolve) => setTimeout(resolve, milliseconds));\n    // return timers.setTimeout(milliseconds);\n\n  } else {\n    console.warn(\"\u26A0\uFE0F waitForSimulation() - .setSimulationInterval() is a must.\");\n    return Promise.resolve();\n  }\n}\n\n/**\n * Wait for next patch\n */\nconst _originalBroadcastPatch = Room.prototype['broadcastPatch'];\nRoom.prototype['broadcastPatch'] = function(this: Room) {\n  const retVal = _originalBroadcastPatch.apply(this, arguments);\n  if (this._waitingForPatch) {\n    setTimeout(() => this._waitingForPatch[1].resolve(), this._waitingForPatch[0]);\n  }\n  return retVal;\n};\nRoom.prototype.waitForNextPatch = async function (this: Room, additionalDelay: number = 0) {\n  this._waitingForPatch = [additionalDelay, new Deferred()];\n  return this._waitingForPatch[1];\n}\n\n// ----------------------------------------------------------------------------------------\n// CLIENT-SIDE EXTENSIONS\n// ----------------------------------------------------------------------------------------\n\ndeclare module \"colyseus.js\" {\n  interface Room {\n    waitForMessage(messageType: string, rejectTimeout?: number): Promise<any>;\n    waitForNextMessage(additionalDelay?: number): Promise<[string, any]>;\n    waitForNextPatch(): Promise<void>;\n    _waitingForMessage: [number, Deferred];\n    _waitingForPatch: [number, Deferred];\n  }\n}\n\nClientRoom.prototype.waitForMessage = async function(this: Room, type: string, rejectTimeout: number = 3000) {\n  return new Promise((resolve, reject) => {\n    const received = (message) => {\n      unbind();\n      resolve(message);\n      clearTimeout(rejectionTimeout);\n    }\n    const unbind = this['onMessageHandlers'].on(type, (message) => received(message));\n\n    const rejectionTimeout = setTimeout(() => {\n      unbind();\n      reject(new Error(`message '${type}' was not called. timed out (${rejectTimeout}ms)`));\n    }, rejectTimeout);\n  });\n}\n\nconst _originalClientOnMessage = ClientRoom.prototype['dispatchMessage'];\nClientRoom.prototype['dispatchMessage'] = function(this: ClientRoom) {\n  _originalClientOnMessage.apply(this, arguments);\n  if (this._waitingForMessage) {\n    setTimeout(() => {\n      this._waitingForMessage[1].resolve([arguments[0], arguments[1]]);\n    }, this._waitingForMessage[0]);\n  }\n};\nClientRoom.prototype.waitForNextMessage = async function(this: Room, additionalDelay: number = 0) {\n  this._waitingForMessage = [additionalDelay, new Deferred()];\n  return this._waitingForMessage[1];\n}\n\nconst _originalClientPatch = ClientRoom.prototype['patch'];\nClientRoom.prototype['patch'] = function(this: ClientRoom) {\n  _originalClientPatch.apply(this, arguments);\n  if (this._waitingForPatch) {\n    setTimeout(() => {\n      this._waitingForPatch[1].resolve([arguments[0], arguments[1]]);\n    }, this._waitingForPatch[0]);\n  }\n};\nClientRoom.prototype.waitForNextPatch = async function(this: ClientRoom, additionalDelay: number = 0) {\n  this._waitingForPatch = [additionalDelay, new Deferred()];\n  return this._waitingForPatch[1];\n}"],
  "mappings": "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",
  "names": ["ClientRoom"]
}
