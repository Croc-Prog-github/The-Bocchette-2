import WebSocket from "ws";
import { Protocol, ClientState, getMessageBytes, logger, debugMessage } from "@colyseus/core";
import { Schema } from "@colyseus/schema";
const SEND_OPTS = { binary: true };
class WebSocketClient {
  constructor(id, ref) {
    this.id = id;
    this.ref = ref;
    this.sessionId = id;
  }
  sessionId;
  state = ClientState.JOINING;
  _enqueuedMessages = [];
  _afterNextPatchQueue;
  _reconnectionToken;
  sendBytes(type, bytes, options) {
    debugMessage("send bytes(to %s): '%s' -> %j", this.sessionId, type, bytes);
    this.enqueueRaw(
      getMessageBytes.raw(Protocol.ROOM_DATA_BYTES, type, void 0, bytes),
      options
    );
  }
  send(messageOrType, messageOrOptions, options) {
    debugMessage("send(to %s): '%s' -> %j", this.sessionId, messageOrType, messageOrOptions);
    this.enqueueRaw(
      messageOrType instanceof Schema ? getMessageBytes[Protocol.ROOM_DATA_SCHEMA](messageOrType) : getMessageBytes.raw(Protocol.ROOM_DATA, messageOrType, messageOrOptions),
      options
    );
  }
  enqueueRaw(data, options) {
    if (options?.afterNextPatch) {
      this._afterNextPatchQueue.push([this, arguments]);
      return;
    }
    if (this.state === ClientState.JOINING) {
      this._enqueuedMessages.push(data);
      return;
    }
    this.raw(data, options);
  }
  raw(data, options, cb) {
    if (this.ref.readyState !== WebSocket.OPEN) {
      return;
    }
    this.ref.send(data, SEND_OPTS, cb);
  }
  error(code, message = "", cb) {
    this.raw(getMessageBytes[Protocol.ERROR](code, message), void 0, cb);
  }
  get readyState() {
    return this.ref.readyState;
  }
  leave(code, data) {
    this.ref.close(code, data);
  }
  close(code, data) {
    logger.warn("DEPRECATION WARNING: use client.leave() instead of client.close()");
    try {
      throw new Error();
    } catch (e) {
      logger.info(e.stack);
    }
    this.leave(code, data);
  }
  toJSON() {
    return { sessionId: this.sessionId, readyState: this.readyState };
  }
}
export {
  WebSocketClient
};
