import { ErrorCode, Protocol } from "./Protocol";
import { requestFromIPC, subscribeIPC } from "./IPC";
import { Deferred, generateId, merge, REMOTE_ROOM_SHORT_TIMEOUT, retry } from "./utils/Utils";
import { isDevMode, cacheRoomHistory, getPreviousProcessId, getRoomRestoreListKey, reloadFromCache } from "./utils/DevMode";
import { RegisteredHandler } from "./matchmaker/RegisteredHandler";
import { RoomInternalState } from "./Room";
import { LocalPresence } from "./presence/LocalPresence";
import { debugAndPrintError, debugMatchMaking } from "./Debug";
import { SeatReservationError } from "./errors/SeatReservationError";
import { ServerError } from "./errors/ServerError";
import { MatchMakerDriver, LocalDriver } from "./matchmaker/driver";
import controller from "./matchmaker/controller";
import { logger } from "./Logger";
import { getHostname } from "./discovery";
const handlers = {};
const rooms = {};
let publicAddress;
let processId;
let presence;
let driver;
let isGracefullyShuttingDown;
let onReady;
async function setup(_presence, _driver, _publicAddress) {
  onReady = new Deferred();
  presence = _presence || new LocalPresence();
  driver = _driver || new LocalDriver();
  publicAddress = _publicAddress;
  if (isDevMode) {
    processId = await getPreviousProcessId(await getHostname());
  }
  if (!processId) {
    processId = generateId();
  }
  isGracefullyShuttingDown = false;
  subscribeIPC(presence, processId, getProcessChannel(), (_, args) => {
    return handleCreateRoom.apply(void 0, args);
  });
  await presence.hset(getRoomCountKey(), processId, "0");
  if (isDevMode) {
    await reloadFromCache();
  }
  onReady.resolve();
}
async function joinOrCreate(roomName, clientOptions = {}) {
  return await retry(async () => {
    let room = await findOneRoomAvailable(roomName, clientOptions);
    if (!room) {
      room = await createRoom(roomName, clientOptions);
    }
    return await reserveSeatFor(room, clientOptions);
  }, 5, [SeatReservationError]);
}
async function create(roomName, clientOptions = {}) {
  const room = await createRoom(roomName, clientOptions);
  return reserveSeatFor(room, clientOptions);
}
async function join(roomName, clientOptions = {}) {
  return await retry(async () => {
    const room = await findOneRoomAvailable(roomName, clientOptions);
    if (!room) {
      throw new ServerError(ErrorCode.MATCHMAKE_INVALID_CRITERIA, `no rooms found with provided criteria`);
    }
    return reserveSeatFor(room, clientOptions);
  });
}
async function reconnect(roomId, clientOptions = {}) {
  const room = await driver.findOne({ roomId });
  if (!room) {
    logger.info(`\u274C room "${roomId}" has been disposed. Did you missed .allowReconnection()?
\u{1F449} https://docs.colyseus.io/server/room/#allowreconnection-client-seconds`);
    throw new ServerError(ErrorCode.MATCHMAKE_INVALID_ROOM_ID, `room "${roomId}" has been disposed.`);
  }
  const reconnectionToken = clientOptions.reconnectionToken;
  if (!reconnectionToken) {
    throw new ServerError(ErrorCode.MATCHMAKE_UNHANDLED, `'reconnectionToken' must be provided for reconnection.`);
  }
  const sessionId = await remoteRoomCall(room.roomId, "checkReconnectionToken", [reconnectionToken]);
  if (sessionId) {
    return { room, sessionId };
  } else {
    logger.info(`\u274C reconnection token invalid or expired. Did you missed .allowReconnection()?
\u{1F449} https://docs.colyseus.io/server/room/#allowreconnection-client-seconds`);
    throw new ServerError(ErrorCode.MATCHMAKE_EXPIRED, `reconnection token invalid or expired.`);
  }
}
async function joinById(roomId, clientOptions = {}) {
  const room = await driver.findOne({ roomId });
  if (!room) {
    throw new ServerError(ErrorCode.MATCHMAKE_INVALID_ROOM_ID, `room "${roomId}" not found`);
  } else if (room.locked) {
    throw new ServerError(ErrorCode.MATCHMAKE_INVALID_ROOM_ID, `room "${roomId}" is locked`);
  }
  return reserveSeatFor(room, clientOptions);
}
async function query(conditions = {}) {
  return await driver.find(conditions);
}
async function findOneRoomAvailable(roomName, clientOptions) {
  return await awaitRoomAvailable(roomName, async () => {
    const handler = handlers[roomName];
    if (!handler) {
      throw new ServerError(ErrorCode.MATCHMAKE_NO_HANDLER, `provided room name "${roomName}" not defined`);
    }
    const roomQuery = driver.findOne({
      locked: false,
      name: roomName,
      private: false,
      ...handler.getFilterOptions(clientOptions)
    });
    if (handler.sortOptions) {
      roomQuery.sort(handler.sortOptions);
    }
    return await roomQuery;
  });
}
async function remoteRoomCall(roomId, method, args, rejectionTimeout = REMOTE_ROOM_SHORT_TIMEOUT) {
  const room = rooms[roomId];
  if (!room) {
    try {
      return await requestFromIPC(presence, getRoomChannel(roomId), method, args);
    } catch (e) {
      const request = `${method}${args && " with args " + JSON.stringify(args) || ""}`;
      throw new ServerError(
        ErrorCode.MATCHMAKE_UNHANDLED,
        `remote room (${roomId}) timed out, requesting "${request}". (${rejectionTimeout}ms exceeded)`
      );
    }
  } else {
    return !args && typeof room[method] !== "function" ? room[method] : await room[method].apply(room, args && args.map((arg) => JSON.parse(JSON.stringify(arg))));
  }
}
function defineRoomType(name, klass, defaultOptions) {
  const registeredHandler = new RegisteredHandler(klass, defaultOptions);
  handlers[name] = registeredHandler;
  if (!isDevMode) {
    cleanupStaleRooms(name);
  }
  return registeredHandler;
}
function removeRoomType(name) {
  delete handlers[name];
  if (!isDevMode) {
    cleanupStaleRooms(name);
  }
}
function hasHandler(name) {
  return handlers[name] !== void 0;
}
async function createRoom(roomName, clientOptions) {
  const roomsSpawnedByProcessId = await presence.hgetall(getRoomCountKey());
  const processIdWithFewerRooms = Object.keys(roomsSpawnedByProcessId).sort((p1, p2) => {
    return Number(roomsSpawnedByProcessId[p1]) > Number(roomsSpawnedByProcessId[p2]) ? 1 : -1;
  })[0] || processId;
  let room;
  if (processIdWithFewerRooms === processId) {
    room = await handleCreateRoom(roomName, clientOptions);
  } else {
    try {
      room = await requestFromIPC(
        presence,
        getProcessChannel(processIdWithFewerRooms),
        void 0,
        [roomName, clientOptions],
        REMOTE_ROOM_SHORT_TIMEOUT
      );
    } catch (e) {
      await presence.hdel(getRoomCountKey(), processIdWithFewerRooms);
      debugAndPrintError(e);
      room = await handleCreateRoom(roomName, clientOptions);
    }
  }
  if (isDevMode) {
    presence.hset(getRoomRestoreListKey(), room.roomId, JSON.stringify({
      "clientOptions": clientOptions,
      "roomName": roomName,
      "processId": processId
    }));
  }
  return room;
}
async function handleCreateRoom(roomName, clientOptions, restoringRoomId) {
  const registeredHandler = handlers[roomName];
  if (!registeredHandler) {
    throw new ServerError(ErrorCode.MATCHMAKE_NO_HANDLER, `provided room name "${roomName}" not defined`);
  }
  const room = new registeredHandler.klass();
  if (restoringRoomId && isDevMode) {
    room.roomId = restoringRoomId;
  } else {
    room.roomId = generateId();
  }
  room.roomName = roomName;
  room.presence = presence;
  const additionalListingData = registeredHandler.getFilterOptions(clientOptions);
  if (publicAddress) {
    additionalListingData.publicAddress = publicAddress;
  }
  room.listing = driver.createInstance({
    name: roomName,
    processId,
    ...additionalListingData
  });
  if (room.onCreate) {
    try {
      await room.onCreate(merge({}, clientOptions, registeredHandler.options));
      presence.hincrby(getRoomCountKey(), processId, 1);
    } catch (e) {
      debugAndPrintError(e);
      throw new ServerError(
        e.code || ErrorCode.MATCHMAKE_UNHANDLED,
        e.message
      );
    }
  }
  room["_internalState"] = RoomInternalState.CREATED;
  room.listing.roomId = room.roomId;
  room.listing.maxClients = room.maxClients;
  debugMatchMaking("spawning '%s', roomId: %s, processId: %s", roomName, room.roomId, processId);
  room._events.on("lock", lockRoom.bind(this, room));
  room._events.on("unlock", unlockRoom.bind(this, room));
  room._events.on("join", onClientJoinRoom.bind(this, room));
  room._events.on("leave", onClientLeaveRoom.bind(this, room));
  room._events.once("dispose", disposeRoom.bind(this, roomName, room));
  room._events.once("disconnect", () => room._events.removeAllListeners());
  await createRoomReferences(room, true);
  await room.listing.save();
  registeredHandler.emit("create", room);
  return room.listing;
}
function getRoomById(roomId) {
  return rooms[roomId];
}
function disconnectAll(closeCode) {
  const promises = [];
  for (const roomId in rooms) {
    if (!rooms.hasOwnProperty(roomId)) {
      continue;
    }
    promises.push(rooms[roomId].disconnect(closeCode));
  }
  return promises;
}
async function gracefullyShutdown() {
  if (isGracefullyShuttingDown) {
    return Promise.reject("already_shutting_down");
  }
  isGracefullyShuttingDown = true;
  debugMatchMaking(`${processId} is shutting down!`);
  if (isDevMode) {
    await cacheRoomHistory(rooms);
  }
  presence.hdel(getRoomCountKey(), processId);
  presence.unsubscribe(getProcessChannel());
  return Promise.all(disconnectAll(
    isDevMode ? Protocol.WS_CLOSE_DEVMODE_RESTART : void 0
  ));
}
async function reserveSeatFor(room, options) {
  const sessionId = generateId();
  debugMatchMaking(
    "reserving seat. sessionId: '%s', roomId: '%s', processId: '%s'",
    sessionId,
    room.roomId,
    processId
  );
  let successfulSeatReservation;
  try {
    successfulSeatReservation = await remoteRoomCall(room.roomId, "_reserveSeat", [sessionId, options]);
  } catch (e) {
    debugMatchMaking(e);
    successfulSeatReservation = false;
  }
  if (!successfulSeatReservation) {
    throw new SeatReservationError(`${room.roomId} is already full.`);
  }
  const response = { room, sessionId };
  if (isDevMode) {
    response.devMode = isDevMode;
  }
  return response;
}
async function cleanupStaleRooms(roomName) {
  const cachedRooms = await driver.find({ name: roomName }, { _id: 1 });
  await presence.del(getHandlerConcurrencyKey(roomName));
  await Promise.all(cachedRooms.map(async (room) => {
    try {
      await remoteRoomCall(room.roomId, "roomId");
    } catch (e) {
      debugMatchMaking(`cleaning up stale room '${roomName}', roomId: ${room.roomId}`);
      room.remove();
    }
  }));
}
async function createRoomReferences(room, init = false) {
  rooms[room.roomId] = room;
  if (init) {
    await subscribeIPC(
      presence,
      processId,
      getRoomChannel(room.roomId),
      (method, args) => {
        return !args && typeof room[method] !== "function" ? room[method] : room[method].apply(room, args);
      }
    );
  }
  return true;
}
async function awaitRoomAvailable(roomToJoin, callback) {
  return new Promise(async (resolve, reject) => {
    const concurrencyKey = getHandlerConcurrencyKey(roomToJoin);
    const concurrency = await presence.incr(concurrencyKey) - 1;
    const concurrencyTimeout = Math.min(concurrency * 100, REMOTE_ROOM_SHORT_TIMEOUT);
    if (concurrency > 0) {
      debugMatchMaking(
        "receiving %d concurrent requests for joining '%s' (waiting %d ms)",
        concurrency,
        roomToJoin,
        concurrencyTimeout
      );
    }
    setTimeout(async () => {
      try {
        const result = await callback();
        resolve(result);
      } catch (e) {
        reject(e);
      } finally {
        await presence.decr(concurrencyKey);
      }
    }, concurrencyTimeout);
  });
}
function onClientJoinRoom(room, client) {
  presence.incr(getGlobalCCUCounter());
  handlers[room.roomName].emit("join", room, client);
}
function onClientLeaveRoom(room, client, willDispose) {
  presence.decr(getGlobalCCUCounter());
  handlers[room.roomName].emit("leave", room, client, willDispose);
}
function lockRoom(room) {
  handlers[room.roomName].emit("lock", room);
}
async function unlockRoom(room) {
  if (await createRoomReferences(room)) {
    handlers[room.roomName].emit("unlock", room);
  }
}
async function disposeRoom(roomName, room) {
  debugMatchMaking("disposing '%s' (%s) on processId '%s'", roomName, room.roomId, processId);
  if (!isGracefullyShuttingDown) {
    presence.hincrby(getRoomCountKey(), processId, -1);
    if (isDevMode) {
      await presence.hdel(getRoomRestoreListKey(), room.roomId);
    }
  }
  handlers[roomName].emit("dispose", room);
  presence.del(getHandlerConcurrencyKey(roomName));
  presence.unsubscribe(getRoomChannel(room.roomId));
  delete rooms[room.roomId];
}
function getRoomCountKey() {
  return "roomcount";
}
function getRoomChannel(roomId) {
  return `$${roomId}`;
}
function getHandlerConcurrencyKey(name) {
  return `c:${name}`;
}
function getProcessChannel(id = processId) {
  return `p:${id}`;
}
function getGlobalCCUCounter() {
  return "_ccu";
}
export {
  MatchMakerDriver,
  controller,
  create,
  createRoom,
  defineRoomType,
  disconnectAll,
  driver,
  findOneRoomAvailable,
  getRoomById,
  getRoomCountKey,
  gracefullyShutdown,
  handleCreateRoom,
  hasHandler,
  isGracefullyShuttingDown,
  join,
  joinById,
  joinOrCreate,
  onReady,
  presence,
  processId,
  publicAddress,
  query,
  reconnect,
  remoteRoomCall,
  removeRoomType,
  reserveSeatFor,
  setup
};
