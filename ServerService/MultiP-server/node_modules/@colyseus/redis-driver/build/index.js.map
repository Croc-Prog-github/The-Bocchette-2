{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import Redis, { Cluster, ClusterNode, ClusterOptions, RedisOptions } from 'ioredis';\n\nimport {\n  IRoomListingData,\n  MatchMakerDriver,\n  QueryHelpers,\n  RoomListingData,\n} from '@colyseus/core';\n\nimport { Query } from './Query';\nimport { RoomData } from './RoomData';\n\nexport class RedisDriver implements MatchMakerDriver {\n  private readonly _client: Redis | Cluster;\n\n  constructor(options?: number | string | RedisOptions | ClusterNode[], clusterOptions?: ClusterOptions) {\n    this._client = (Array.isArray(options))\n      ? new Cluster(options, clusterOptions)\n      : new Redis(options as RedisOptions);\n  }\n\n  public createInstance(initialValues: any = {}) {\n    return new RoomData(initialValues, this._client);\n  }\n\n  public async has(roomId: string) {\n    return await this._client.hexists('roomcaches', roomId) === 1;\n  }\n\n  public async find(conditions: any) {\n    const rooms = await this.getRooms();\n    return rooms.filter((room) => {\n      if (!room.roomId) {\n        return false;\n      }\n\n      for (const field in conditions) {\n        if (\n          conditions.hasOwnProperty(field) &&\n          room[field] !== conditions[field]\n        ) {\n          return false;\n        }\n      }\n      return true;\n    });\n  }\n\n  public findOne(conditions: Partial<IRoomListingData>): QueryHelpers<RoomListingData> {\n    if (typeof conditions.roomId !== 'undefined') {\n      // get room by roomId\n\n      //\n      // TODO: refactor driver APIs.\n      // the API here is legacy from MongooseDriver which made sense on versions <= 0.14.0\n      //\n\n      // @ts-ignore\n      return new Promise<RoomListingData>((resolve, reject) => {\n        this._client.hget('roomcaches', conditions.roomId).then((roomcache) => {\n          if (roomcache) {\n            resolve(new RoomData(JSON.parse(roomcache), this._client));\n          } else {\n            resolve(undefined);\n          }\n        }).catch(reject);\n      });\n\n    } else {\n      // filter list by other conditions\n      return (new Query<RoomListingData>(this.getRooms(), conditions) as any) as QueryHelpers<RoomListingData>;\n    }\n  }\n\n  public async getRooms() {\n    return Object.entries(await this._client.hgetall('roomcaches') ?? []).map(\n      ([, roomcache]) => new RoomData(JSON.parse(roomcache), this._client)\n    );\n  }\n\n  public async shutdown() {\n    await this._client.quit();\n  }\n\n  //\n  // only relevant for the test-suite.\n  // not used during runtime.\n  //\n  public clear() {\n    this._client.del('roomcaches');\n  }\n\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAA0E;AAS1E,mBAAsB;AACtB,sBAAyB;AAElB,MAAM,YAAwC;AAAA,EAClC;AAAA,EAEjB,YAAY,SAA0D,gBAAiC;AACrG,SAAK,UAAW,MAAM,QAAQ,OAAO,IACjC,IAAI,uBAAQ,SAAS,cAAc,IACnC,IAAI,eAAAA,QAAM,OAAuB;AAAA,EACvC;AAAA,EAEO,eAAe,gBAAqB,CAAC,GAAG;AAC7C,WAAO,IAAI,yBAAS,eAAe,KAAK,OAAO;AAAA,EACjD;AAAA,EAEA,MAAa,IAAI,QAAgB;AAC/B,WAAO,MAAM,KAAK,QAAQ,QAAQ,cAAc,MAAM,MAAM;AAAA,EAC9D;AAAA,EAEA,MAAa,KAAK,YAAiB;AACjC,UAAM,QAAQ,MAAM,KAAK,SAAS;AAClC,WAAO,MAAM,OAAO,CAAC,SAAS;AAC5B,UAAI,CAAC,KAAK,QAAQ;AAChB,eAAO;AAAA,MACT;AAEA,iBAAW,SAAS,YAAY;AAC9B,YACE,WAAW,eAAe,KAAK,KAC/B,KAAK,WAAW,WAAW,QAC3B;AACA,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAAA,EAEO,QAAQ,YAAsE;AACnF,QAAI,OAAO,WAAW,WAAW,aAAa;AAS5C,aAAO,IAAI,QAAyB,CAAC,SAAS,WAAW;AACvD,aAAK,QAAQ,KAAK,cAAc,WAAW,MAAM,EAAE,KAAK,CAAC,cAAc;AACrE,cAAI,WAAW;AACb,oBAAQ,IAAI,yBAAS,KAAK,MAAM,SAAS,GAAG,KAAK,OAAO,CAAC;AAAA,UAC3D,OAAO;AACL,oBAAQ,MAAS;AAAA,UACnB;AAAA,QACF,CAAC,EAAE,MAAM,MAAM;AAAA,MACjB,CAAC;AAAA,IAEH,OAAO;AAEL,aAAQ,IAAI,mBAAuB,KAAK,SAAS,GAAG,UAAU;AAAA,IAChE;AAAA,EACF;AAAA,EAEA,MAAa,WAAW;AACtB,WAAO,OAAO,QAAQ,MAAM,KAAK,QAAQ,QAAQ,YAAY,KAAK,CAAC,CAAC,EAAE;AAAA,MACpE,CAAC,CAAC,EAAE,SAAS,MAAM,IAAI,yBAAS,KAAK,MAAM,SAAS,GAAG,KAAK,OAAO;AAAA,IACrE;AAAA,EACF;AAAA,EAEA,MAAa,WAAW;AACtB,UAAM,KAAK,QAAQ,KAAK;AAAA,EAC1B;AAAA,EAMO,QAAQ;AACb,SAAK,QAAQ,IAAI,YAAY;AAAA,EAC/B;AAEF;",
  "names": ["Redis"]
}
